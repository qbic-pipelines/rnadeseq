---
# Written by Gisela Gabernet, Stefan Czemmel, Silvia Morini, Oskar Wacker, QBiC and released under the MIT License
output:
    html_document:
        toc: true # table of contents
        toc_float: true # float the table of contents to the left of the main document content
        toc_depth: 3 # header levels 1,2,3
        theme: default
        number_sections: true # add section numbering to headers
        df_print: paged # tables are printed as an html table with support for pagination over rows and columns
        css: ./corp-styles.css
        highlight: pygments
        pdf_document: true
bibliography: ./references.bibtex
params:

    #Main input args
    input_type: ''
    path_gene_counts: ''
    path_metadata: ''
    path_design: ''
    path_gtf: '' # only for star_rsem and star_salmon input

    #DESeq2 args
    path_contrast_matrix: ''
    path_contrast_list: ''
    path_contrast_pairs: ''
    path_genelist: ''
    path_relevel: ''
    batch_effect: ''
    logFC_threshold: ''
    adj_pval_threshold: ''
    norm_method: ''
    nsub_genes: ''
    round_DE: ''

    #Pathway analysis args
    pathway_analysis: ''
    organism: ''
    species_library: ''
    keytype: ''
    min_DEG_pathway: ''
    custom_gmt: ''
    set_background: ''
    custom_background: ''
    datasources: ''
    heatmaps_cluster_rows: ''
    heatmaps_cluster_cols: ''
    pathway_adj_pval_threshold: ''

    #Additional args for the report
    path_proj_summary: ''
    path_quote: ''
    path_software_versions: ''
    revision: ''
    logo: ''

    #Additional arg to indicate that a github test is run
    citest: ''

# Author: Silvia Morini, Gisela Gabernet, Simon Heumos
---

```{r init, include=F}
# set a seed in case some background calculations are random-based
set.seed(10)

# svg path for the little svg format icon displayed in the interactive plots for svg export; based on https://www.svgviewer.dev/:
svg_icon_path <- 'M228 319.5H12C5.64873 319.5 0.5 314.351 0.5 308V12C0.5 5.64873 5.64873 0.5 12 0.5H159.175C159.571 0.5 159.952 0.656748 160.233 0.936021L239.057 79.2681C239.341 79.5497 239.5 79.9326 239.5 80.3321V308C239.5 314.351 234.351 319.5 228 319.5Z'
svg_icon_fill <- 'darkgrey'
svg_icon_transform <- 'scale(0.07)'
svg_icon_viewbox <- '0 0 240 320'

# This adds a save-to-svg button to the plot menubar
svg_exp <- list(
    name = "Download plot as an svg",
    icon = list(
        path = svg_icon_path,
        fill = svg_icon_fill,
        transform = svg_icon_transform,
        viewbox = svg_icon_viewbox
    ),
    click = htmlwidgets::JS(
        "function(pg) {
            Plotly.downloadImage(pg, {format: 'svg', filename: 'newplot'});
        }"
    )
)

# Function for setting heatmap row/column label size depending on number of rows/columns
label_size <- function(dimension_int) {
    val <- max(c(2, 10-dimension_int/15))
    return(val)
}

# Function for creating a dataframe from smrnaseq files
build_smrnaseq_df <- function(files) {
    merged_mat <- F
    for (f in files) {
        file_tab <- read.table(f, sep="\t", row.names=1)
        # Usually, the last row is weird and has the rowname *, remove it
        if (grep("*", tail(rownames(file_tab), n=1), fixed=T)) {
            file_tab <- head(file_tab, -1)
        }

        # If merged_mat already exists, add third matrix column to it (second column after rownames)
        if (is.data.frame(merged_mat)) {

            # Check if rownames are the same
            if (!identical(rownames(file_tab), rownames(merged_mat))) {
                stop(paste("Rownames of smrnaseq file", file_tab, "differ from the rownames of the other files; exiting..."))
            }
            # Create column from QBiC code of current file name (substring of length 10)
            merged_mat[[substr(basename(f), 1, 10)]] <- file_tab[,2]
        } else {

            # Otherwise initiate it from third matrix column and rownames; as above, only use QBiC code, not full file name
            merged_mat <- data.frame(file_tab[,2])
            rownames(merged_mat) <- rownames(file_tab)
            colnames(merged_mat) <- c(substr(basename(f), 1, 10))
        }
    }
    merged_mat
}
```

```{r param_validation, echo=FALSE, message=FALSE, warning=FALSE, results = 'hide'}
#self-written isProvided function that tests for zero-length, emptystring and NULL (for some reason, some params cannot be tested with emptystring)
isProvided <- function(value) {
    result <- TRUE
    tryCatch(
    {
        if (length(value)<1) {
            result <- FALSE
        }
        else {
            tryCatch(
        {
            if (value %in% c("", "null", "NULL", "false", "FALSE")) {
                result <- FALSE
            }
        },
        error=function(cond) {
            tryCatch(
                {
                    if (is.null(value)) {
                        result <- FALSE
                    }
                },
                error=function(cond) {
                    message("isProvided got the following error:")
                    message(cond)
                    message(paste("Object type:", typeof(value)))
                    message(paste("Object:", value))
                    quit(1)
                }
            )
        }
    )
        }
    },
    error=function(cond) {
        message("isProvided got the following error:")
                    message(cond)
                    message(paste("Object type:", typeof(value)))
                    message(paste("Object:", value))
                    quit(1)
    }
    )
    return(result)
}

#this function is used to produce a more informative error message when count table and metadata table disagree
write_error_msg <- function(counts, qbicCodes) {
    error_msg <- "Count table headers do not exactly match the metadata table sample names!\n"

    counts_msg <- ""
    counts_offending <- ""
    for (c in names(counts)) {
        if (!(c %in% qbicCodes)) {
            counts_msg <- "Offending value(s) in count table:\n"
            counts_offending <- paste0(counts_offending, c, "\n")
        }
    }

    meta_msg <- ""
    meta_offending <- ""
    for (m in qbicCodes) {
        if (!(m %in% names(counts))) {
            meta_msg <- "Offending value(s) in metadata table:\n"
            meta_offending <- paste0(meta_offending, m, "\n")
        }
    }
    return(paste0(error_msg, counts_msg, counts_offending, meta_msg, meta_offending))
}

#Check necessary params
if (!(params$input_type %in% c("featurecounts", "rsem", "salmon", "smrnaseq"))){
    stop(paste0("Wrong input type ", params$input_type, ", must be one of [featurecounts, rsem, salmon, smrnaseq]!"))
}
if (params$input_type %in% c("rsem", "salmon") & !isProvided(params$path_gtf)){
    stop(paste0("For input type salmon, gtf file needs to be provided!\nIf using igenomes, please check that the entry for your genome contains a gtf file and otherwise provide one with `--gtf`."))
}
if (!isProvided(params$path_gene_counts)){
    print_help(opt_parser)
    stop("Counts table needs to be provided!")
}
if (!isProvided(params$path_metadata)){
    print_help(opt_parser)
    stop("Metadata table needs to be provided!")
}
if (!isProvided(params$path_design)){
    print_help(opt_parser)
    stop("Linear model design file needs to be provided!")
}

# Check if more than one contrast option was provided
contrast_vector <- c(isProvided(params$path_contrast_list), isProvided(params$path_contrast_matrix), isProvided(params$path_contrast_pairs))
if (length(contrast_vector[contrast_vector==TRUE]) > 1) {
    stop("Provide only one of contrasts_matrix / contrasts_list / contrasts pairs!")
}
```

```{r load_DE_libs, echo=FALSE, message=FALSE, warning=FALSE, results = 'hide'}
# Load all necessary libs invisibly
invisible( lapply(c(
"RColorBrewer",
"reshape2",
"genefilter",
"DESeq2",
"ggplot2",
"ggrepel",
"dplyr",
"plyr",
"vsn",
"gplots",
"optparse",
"svglite",
"extrafont",
"limma",
"tximeta",
"tximport",
"SummarizedExperiment",
"impute",
"kableExtra",
"knitr",
"formattable",
"webshot",
"htmlwidgets",
"pheatmap",
"DT",
"sessioninfo",
"details",
"heatmaply",
"tools",
"yaml"
), library, character.only=T))
```

```{r create_outdirs, echo=FALSE, message=FALSE, warning=FALSE, results = 'hide'}
# create directories needed
ifelse(!dir.exists("differential_gene_expression"), dir.create("differential_gene_expression"), FALSE)
dir.create("differential_gene_expression/metadata")
dir.create("differential_gene_expression/plots")
dir.create("differential_gene_expression/plots/boxplots_example_genes")
dir.create("differential_gene_expression/plots/boxplots_requested_genes")
dir.create("differential_gene_expression/plots/further_diagnostics_plots")
dir.create("differential_gene_expression/plots/volcano_plots/")
dir.create("differential_gene_expression/gene_counts_tables")
dir.create("differential_gene_expression/DE_genes_tables")
dir.create("differential_gene_expression/allgenes")
dir.create("differential_gene_expression/final_gene_table")
```

```{r project_data, bootstrap.show.message=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
df <- read.csv(file = params$path_proj_summary, sep="\t", header = TRUE)

# Import the .tsv file downloadable from https://portal.qbic.uni-tuebingen.de/portal/web/qbic/user-database -> Projects
projectcode = as.character(df$Sub.Project)

# Set the title; if the title is too long, it would get covered by the logo, so it is split in 2 or 3 parts.
title = as.character(df$Short.Title)

## function to split the title
splitInParts <- function(string, size){
        pat <- paste0('(?<=.{',size,'})')
        strsplit(string, pat, perl=TRUE)
    }
title_split=splitInParts(title, 65)
PI = as.character(df$Principal.Investigator)
PI_address = as.character(df$PI.Address)
PI_email = as.character(df$PI.E.Mail)
PI_institute = as.character(df$PI.Institute)
PI_organization = as.character(df$PI.Organization)
PM = as.character(df$Project.Manager)
PM_email = as.character(df$Manager.E.Mail)
description = as.character(df$Description)
```

---
title: "`r projectcode` - Project Report"
subtitle: "`r sapply(title_split, paste, collapse=" <br> ")`"
author: "`r PM`, Bioinformatics Research Scientist"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
---

```{r logo, echo=FALSE, results='asis'}
logo_file = file.path(getwd(), "logo.png")
img_data <- base64enc::dataURI(file = logo_file, mime = "image/png") # Need to use base64 because the logo will otherwise for some reason not be loaded correctly
cat(sprintf('<img src="%s" style="position:absolute;top:0px;right:0px;" height="200" width="200" />', img_data))
```

<div class="watermark">QBiC</div>

```{r docSetup, bootstrap.show.code = FALSE, dev = c('png'), bootstrap.show.message=FALSE, echo=FALSE, message=FALSE, warning=FALSE}

## knitrBoostrap and device chunk options
options(warn = -1)                          # suppress warnings and messages
opts_chunk$set(bootstrap.show.code = FALSE, dev = 'png', echo=FALSE)
```

\
\
\
\
**Project Members:**

**_`r PI`_**

`r PI_email`

`r PI_institute`

`r PI_organization`

`r PI_address`

\
\
**QBiC contacts:**

**_`r PM`_**

`r PM_email`

Auf der Morgenstelle 10, 72076 Tuebingen

---

---

# Introduction and aims

`r description`

# Sample metadata

<!-- metadata start -->

```{r read_metadata, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
# Load metadata: sample preparations tsv file from qPortal
metadata <- read.table(params$path_metadata, sep="\t", header=TRUE,na.strings =c("","NaN"), quote=NULL, stringsAsFactors=F, dec=".", fill=TRUE, row.names=1)
if (params$pathway_analysis) {

    #create copy of metadata for pathway_analysis
    metadata_PA <- read.table(file=params$path_metadata, sep = "\t", header = T, quote="")
}
system(paste("mv ",params$path_metadata," differential_gene_expression/metadata/metadata.tsv",sep=""))
qbicCodes <- rownames(metadata)

# Make sure metadata is factor where needed
names(metadata) = gsub("Condition..","condition_",names(metadata))
conditions = names(metadata)[grepl("condition_",names(metadata))]
for (i in conditions) {
    metadata[,i] = as.factor(metadata[,i])
}
# process secondary names and change row names in metadata
metadata$Secondary.Name <- gsub(" ; ", "_", metadata$Secondary.Name)
metadata$Secondary.Name <- gsub(" ", "_", metadata$Secondary.Name)
metadata$sampleName = paste(row.names(metadata),metadata$Secondary.Name,sep="_")
row.names(metadata) = metadata$sampleName
metadata_save <- metadata # save copy so that original metadata object can be changed

if (params$input_type == "smrnaseq") {

    # Prepare files from smrnaseq, start with hairpins
    hairpin_files <- file.path(gsub("/$", "", params$path_gene_counts), paste0(qbicCodes, "_mature_hairpin.sorted.idxstats"))
    if (!(all(file.exists(hairpin_files)))) {
        missing_files <- "Could not find all of the specified <QBiC-code>_mature_hairpin.sorted.idxstats files! Please check that for all QBiC codes in the metadata sheet, a <QBiC-code>_mature_hairpin.sorted.idxstats file is present in the gene_counts folder and make sure that no typos exist. The following file(s) could not be found: "
        for (f in hairpin_files) {
            if (!file.exists(f)) {
                missing_files <- paste0(missing_files, f, ", ")
            }
        }
        missing_files <- paste0(substring(missing_files, 1, nchar(missing_files)-2), ".")
        stop(missing_files, call.=F)
    }

    # Non-hairpins next
    other_files <- file.path(gsub("/$", "", params$path_gene_counts), paste0(qbicCodes, "_mature.sorted.idxstats"))
    if (!(all(file.exists(other_files)))) {
        missing_files <- "Could not find all of the specified <QBiC-code>_mature.sorted.idxstats files! Please check that for all QBiC codes in the metadata sheet, a <QBiC-code>_mature.sorted.idxstats file is present in the gene_counts folder and make sure that no typos exist. The following file(s) could not be found: "
        for (f in other_files) {
            if (!file.exists(f)) {
                missing_files <- paste0(missing_files, f, ", ")
            }
        }
        missing_files <- paste0(substring(missing_files, 1, nchar(missing_files)-2), ".")
        stop(missing_files, call.=F)
    }

    # Combine files for later
    files <- c(hairpin_files, other_files)

    # Merge hairpins and counts
    hairpin_df <- build_smrnaseq_df(hairpin_files)
    other_df <- build_smrnaseq_df(other_files)
    colnames(other_df) <- colnames(hairpin_df)
    count.table <- rbind(hairpin_df, other_df)

    # Need to order columns in count.table
    count.table <- count.table[, order(names(count.table))]

    count.table$Ensembl_ID <- rownames(count.table)
    count.table <- cbind(Ensembl_ID=rownames(count.table), gene_name=rownames(count.table), count.table)
    write.table(count.table, paste("differential_gene_expression/gene_counts_tables/raw_gene_counts.tsv",sep=""), append = FALSE, quote = FALSE, sep = "\t",eol = "\n", na = "NA", dec = ".", row.names = F, qmethod = c("escape", "double"))
}

# Load count table for FeatureCounts
if (params$input_type == "featurecounts"){
    count.table <- read.table(params$path_gene_counts,  header = T,sep = "\t",na.strings =c("","NA"),quote=NULL,stringsAsFactors=F,dec=".",fill=TRUE,row.names=1)
}

# Processing is the same for FeatureCounts and the smrnaseq matrix that is built above
if (params$input_type %in% c("featurecounts", "smrnaseq")) {
    count.table$Ensembl_ID <- row.names(count.table)
    drop <- c("Ensembl_ID","gene_name")
    gene_names <- count.table[,drop]

    # Reduce sample names to QBiC codes in count table
    names(count.table) <- substr(names(count.table), 1, 10)
    count.table <- count.table[ , !(names(count.table) %in% drop)]

    # Remove lines with "__" from HTSeq, not needed for featureCounts (will not harm here)
    count.table <- count.table[!grepl("^__",row.names(count.table)),]

    # Do some hard filtering for genes with 0 expression
    count.table = count.table[rowSums(count.table)>0,]

    # Need to order columns in count.table
    count.table <- count.table[, order(names(count.table))]

    if (!identical(names(count.table),qbicCodes)) {
        error_out <- write_error_msg(count.table, qbicCodes)
        stop(paste0(error_out, "\n"), call.=F)
    }
    names(count.table) = metadata$sampleName

    # Write raw counts to file
    count_table_names <- merge(x=gene_names, y=count.table, by.x = "Ensembl_ID", by.y="row.names")
    write.table(count_table_names, paste("differential_gene_expression/gene_counts_tables/raw_gene_counts.tsv", sep=""), append = FALSE, quote = FALSE, sep = "\t", eol = "\n", na = "NA", dec = ".", row.names = F, qmethod = c("escape", "double"))
}

# to get all possible pairwise comparisons, make a combined factor
conditions <- grepl(colnames(metadata),pattern = "condition_")
conditions_contrasts <- conditions # save copy that might be changed in contrast section and will be used for boxplots
metadata$combfactor <- apply(as.data.frame(metadata[ ,conditions]),1,paste, collapse = "_")

# Read design file
design <- read.csv(params$path_design, sep="\t", header = F)
write.table(design, file="differential_gene_expression/metadata/linear_model.txt", sep="\t", quote=F, col.names = F, row.names = F)

# condition: if there is a RIN column in Sample_preparations.tsv, prints a statement and the table with the RIN column;
# if there is no RIN column, or the column has one or more NAs, print only the metadata sheet.
QAfile = paste0(wd, "/differential_gene_expression/metadata/metadata.tsv")

no_RIN = FALSE
RIN=FALSE
if(file.exists(QAfile)){
    df_QA <- read.table(QAfile, header=TRUE, sep="\t", check.names = FALSE)
    conditions <- grepl(colnames(df_QA),pattern = "Condition")
    df_QA_cond <- as.data.frame(df_QA[ ,conditions])
    colnames(df_QA_cond) <- colnames(df_QA)[conditions]
    df_QA_neat <- df_QA[,c("QBiC Code", "Secondary Name")]

    #add "Sample Type" only if present in metadata.tsv
    if ("Sample Type" %in% colnames(df_QA)) {
            df_QA_neat[,c("Sample Type")] <- df_QA[,c("Sample Type")]
    }
    df_QA_neat <- merge(df_QA_neat, df_QA_cond, by="row.names")
    df_QA_neat$Row.names <- NULL
    if ("RIN" %in% colnames(df_QA)) {
        if (any(is.na(df_QA$RIN))) {
            no_RIN <- TRUE
        } else {
            RIN <- TRUE
            df_QA_neat$RIN <- df_QA$RIN
        }
    } else {
        no_RIN <- TRUE
    }
} else {
    no_RIN <- TRUE
}
```

```{r RIN_block, echo=FALSE, results='asis', eval=RIN}
cat("\
The samples description and grouping, including quality assessment of the RNA samples,
is summarized in the table below and can be found [here](./differential_gene_expression/metadata/metadata.tsv).
The RNA Integrity Number (RIN) value has a maximum value of 10.
\
")
kable(df_QA_neat) %>%
    kable_styling() %>%
    scroll_box(width = "100%", height = "400px")
```

```{r noRIN_block, echo=FALSE, results='asis', eval=no_RIN}
cat("\
The samples description and grouping is summarized in the table below and can be
found [here](./differential_gene_expression/metadata/metadata.tsv).
\
")
if ("RIN" %in% colnames(df_QA_neat)){df_QA_neat$RIN <- NULL}
DT::datatable(df_QA_neat, options = list(scrollX  = "100%", scrollY = "400px", pageLength = -1, dom = 'ft'))
```

<!-- DESeq2 start -->
<!-- This block needs to be executed before the rest of the code as the variables will be needed -->

```{r DESeq, echo=FALSE, message=FALSE, warning=FALSE, results = 'hide'}

################## RUN DESEQ2 ######################################
# Run DESeq function
if (params$input_type %in% c("featurecounts", "smrnaseq")) {
    cds <- DESeqDataSetFromMatrix( countData =count.table, colData =metadata, design = eval(parse(text=as.character(design[[1]]))))
} else if (params$input_type %in% c("rsem", "salmon")) {

    ## Create a dataframe which consists of both the gene id and the transcript name
    gtf <- rtracklayer::import(params$path_gtf)
    gtf <- as.data.frame(gtf, header=T)
    tx2gene_gtf <- gtf[c("transcript_id", "gene_id")]
    tx2gene_gtf <- distinct(tx2gene_gtf)

    # As the tximport parameter ignoreTxVersion=T does not reliably work (I think it only ignores the version
    # in the input files, not in the gtf), this removes decimals from the transcript_id values,
    # e.g. transcript_id "AT1G01010.1" --> transcript_id "AT1G01010"
    tx2gene_gtf[] <- lapply(tx2gene_gtf, function(x) gsub("\\.\\d+", "", x))
    colnames(tx2gene_gtf) <- c("transcript_id", "gene_id") #, "TXID"
    gene_names <- gtf[c("gene_id", "gene_name")]

    # Where no gene_name is available, use gene_id instead
    gene_names$gene_name <- ifelse(is.na(gene_names$gene_name), gene_names$gene_id, gene_names$gene_name)
    colnames(gene_names) <- c("Ensembl_ID", "gene_name")
    gene_names <- distinct(gene_names)
    rownames(gene_names) <- gene_names[,1]

## Load Rsem count files
    if (params$input_type == "rsem") {

        #rsem saves output into one file per sample in an output folder
        #-->the sample name is in the file name
        files <- file.path(gsub("/$", "", params$path_gene_counts), paste0(qbicCodes, ".genes.results"))
        if (!(all(file.exists(files)))) {
            missing_files <- "Could not find all of the specified <QBiC-code>.genes.results files! Please check that for all QBiC codes in the metadata sheet, a <QBiC-code>.genes.results file is present in the gene_counts folder and make sure that no typos exist. The following file(s) could not be found: "
            for (f in files) {
                if (!file.exists(f)) {
                    missing_files <- paste0(missing_files, f, ", ")
                }
            }
            missing_files <- paste0(substring(missing_files, 1, nchar(missing_files)-2), ".")
            stop(missing_files, call.=F)
        }

        #Extract condition columns and other info for tximeta
        condition_names <- unlist(strsplit(design[,1], split = " "))
        condition_names <- grep("condition|batch", condition_names, value=T)
        sampleconditions <- data.frame(metadata[,condition_names])
        colnames(sampleconditions) <- condition_names
        coldata <- data.frame(files = files, names= qbicCodes, sampleconditions)
        coldata$combfactor <- metadata$combfactor
        rownames(coldata) <- NULL

        #Do tximeta, this is necessary to run DESeq on rsem (imports the rsem output
        #and modifies them as they are not integers and can not directly be used for cds)
        se <- tximeta(coldata, type="rsem", txIn=FALSE, txOut=FALSE, skipMeta=TRUE)
        assays(se)$length[ assays(se)$length == 0] <- NA # set these as missing

        #Impute lengths for the 0-length values:
        length_imp <- impute.knn(assays(se)$length)
        assays(se)$length <- length_imp$data

        #dds from SummarizedExperiment <se>, then run DESeq
        cds <- DESeqDataSet(se, design = as.formula(eval(parse(text=as.character(design[[1]])))))
        # get raw counts
        count_table_names <- merge(x=gene_names, y=assay(cds), by.x = "Ensembl_ID", by.y="row.names")
        count_table_names <- count_table_names[order(count_table_names$Ensembl_ID),]
        write.table(count_table_names, paste("differential_gene_expression/gene_counts_tables/raw_gene_counts.tsv", sep=""), append = FALSE, quote = FALSE, sep = "\t", eol = "\n", na = "NA", dec = ".", row.names = F, qmethod = c("escape", "double"))

# Load salmon count files
    } else if (params$input_type == "salmon") {

        #salmon saves output to one file per sample, each file is contained in a subfolder of the output folder
        #-->the sample name is in the subfolder name, not in the file name!
        files <- file.path(gsub("/$", "", params$path_gene_counts), qbicCodes, "quant.sf")
        if (!(all(file.exists(files)))) {
            missing_files <- "Could not find all of the specified <QBiC-code>/quant.sf files! Please check that for all QBiC codes in the metadata sheet, a <QBiC-code>/quant.sf file is present in the gene_counts folder and <QBiC-code> subfolder and make sure that no typos exist. The following file(s) could not be found: "
            for (f in files) {
                if (!file.exists(f)) {
                    missing_files <- paste0(missing_files, f, ", ")
                }
            }
            missing_files <- paste0(substring(missing_files, 1, nchar(missing_files)-2), ".")
            stop(missing_files, call.=F)
        }

        #The following steps are necessary for the processing of salmon output as the files do
        # not contain integer counts and can therefore not be directly used for cds
        ## Import all of the samples information and transform the identifiers
        txi.salmon <- tximport(files, type = "salmon", tx2gene = tx2gene_gtf, ignoreTxVersion = T)

        # Run cds with tximport depending on whether rsem or salmon was used
        #Extract condition columns and other info for tximeta
        condition_names <- unlist(strsplit(design[,1], split = " "))
        condition_names <- grep("condition|batch", condition_names, value=T)
        sampleconditions <- data.frame(metadata[,condition_names])
        colnames(sampleconditions) <- condition_names
        coldata <- data.frame(files = files, names= qbicCodes, sampleconditions)
        coldata$combfactor <- metadata$combfactor
        rownames(coldata) <- qbicCodes
        cds <- DESeqDataSetFromTximport(txi=txi.salmon, colData =coldata, design = eval(parse(text=as.character(design[[1]]))))
        # get raw counts
        count_table_names <- merge(x=gene_names, y=assay(cds), by.x = "Ensembl_ID", by.y="row.names")
        count_table_names <- count_table_names[order(count_table_names$Ensembl_ID),]
        write.table(count_table_names, paste("differential_gene_expression/gene_counts_tables/raw_gene_counts.tsv", sep=""), append = FALSE, quote = FALSE, sep = "\t", eol = "\n", na = "NA", dec = ".", row.names = F, qmethod = c("escape", "double"))
    }
} else {
    stop(paste0("Invalid input type: ", params$input_type, "! Input type must be one of: featurecounts, rsem, salmon, smrnaseq!"))
}

#Apply relevel if provided; this must be done before calling DESeq()
if (isProvided(params$path_relevel)) {
    relevel_table <- read.table(params$path_relevel, sep="\t", header = T, colClasses = "character")
    write.table(relevel_table, file="differential_gene_expression/metadata/relevel.tsv")
    for (i in c(1:nrow(relevel_table))) {
        relev <- relevel_table[i,]
        cds[[paste(relev[1])]] <- relevel(cds[[paste(relev[1])]], paste(relev[2]))
    }
}

# Run actual DESeq analysis
cds <- DESeq(cds)

# sizeFactors(cds) as indicator of library sequencing depth
if (params$input_type %in% c("featurecounts", "smrnaseq")) {
    sf <- sizeFactors(cds)
} else {
    # If tximport was used, sizeFactors doesn't work, so use workaround as described here: https://support.bioconductor.org/p/97676/
    nm <- assays(cds)[["avgTxLength"]]
    sf <- estimateSizeFactorsForMatrix(counts(cds)/nm)
}

write.table(sf,paste("differential_gene_expression/gene_counts_tables/sizeFactor_libraries.tsv",sep=""), append = FALSE, quote = FALSE, sep = "\t",eol = "\n", na = "NA", dec = ".", row.names = T,  col.names = F, qmethod = c("escape", "double"))

# Write cds assay table to file
write.table(counts(cds, normalized=T), paste0("differential_gene_expression/gene_counts_tables/deseq2_library_scaled_gene_counts.tsv"), append=F, quote = F, sep = "\t", eol = "\n", na = "NA", dec = ".", row.names = T, col.names = T, qmethod = c("escape", "double"))

# Or for smrnaseq save folder/file names to txt file
if (params$input_type == "smrnaseq") {
    write(files, file="differential_gene_expression/metadata/smrnaseq_files.txt")
}

# Or for rsem/salmon save folder/file names to txt file
if (params$input_type == "rsem") {
    write(files, file="differential_gene_expression/metadata/star_rsem_files.txt")
} else if (params$input_type == "salmon") {
    write(files, file="differential_gene_expression/metadata/star_salmon_files.txt")
}

############################## TRANSFORMED AND NORMALIZED COUNTS ###################
# Prepare variables and text snippets for report
vst_cutoff <- 0.05
var_sizeFactors <- var(sf)
run_rlog <- T
norm_method_long_text <- "regularized logarithm (rlog)"
norm_method_override_text <- ""
nsub_genes_text <- ""
if (params$norm_method == "vst-force") {
    run_rlog <- F
    norm_method_long_text <- "variance stabilizing transformation (vst)"
    nsub_genes_text <- paste0("The number of subset genes for the vst transformation was set to ", as.character(params$nsub_genes), ".")
    if (var_sizeFactors >= vst_cutoff) {
        norm_method_override_text <- paste0(" This was due to using the `--norm_method vst-force` argument. It is recommended to rerun the pipeline using the rlog transformation as the size factors of the different samples have a variance of ~", round(var_sizeFactors, 4), ". For high sample variances (i.e. different sequencing depths between samples), the rlog transformation is more suitable [@love2014differential].")
        nsub_genes_text <- ""
    }
} else if (params$norm_method == "vst") {
    run_rlog <- F
    norm_method_long_text <- "variance stabilizing transformation (vst)"
    nsub_genes_text <- paste0("The number of subset genes for the vst transformation was set to ", as.character(params$nsub_genes), ".")
    if (var_sizeFactors >= vst_cutoff) {
        run_rlog <- T
        norm_method_long_text <- "regularized logarithm (rlog)"
        norm_method_override_text <- paste0(" This was done as the size factors of the different samples have a variance of ~", round(var_sizeFactors, 4), ". For high sample variances (i.e. different sequencing depths between samples), the rlog transformation is more suitable [@love2014differential].")
        nsub_genes_text <- ""
    }
}
norm_method_text <- ifelse(run_rlog, "rlog", "vst")

if (run_rlog){

    # rlog transformation
    rld <- rlog(cds, blind=FALSE)
    rld_names <- merge(x=gene_names, y=assay(rld), by.x = "Ensembl_ID", by.y="row.names")
    rld_names <- rld_names[order(rld_names$Ensembl_ID),]
    write.table(rld_names, "differential_gene_expression/gene_counts_tables/rlog_transformed_gene_counts.tsv", append = FALSE, quote = FALSE, sep = "\t",eol = "\n", na = "NA", dec = ".", row.names = F,  qmethod = c("escape", "double"))

    # save table to another variable if pathway analysis
    if (params$pathway_analysis) {
        norm_counts <- rld_names
        rownames(norm_counts) <- norm_counts$Ensembl_ID
    }

} else {

    # vst transformation
    vsd <- vst(cds, blind=FALSE, nsub = params$nsub_genes)
    vsd_names <- merge(x=gene_names, y=assay(vsd), by.x = "Ensembl_ID", by.y="row.names")
    vsd_names <- vsd_names[order(vsd_names$Ensembl_ID),]
    write.table(vsd_names, "differential_gene_expression/gene_counts_tables/vst_transformed_gene_counts.tsv", append = FALSE, quote = FALSE, sep = "\t",eol = "\n", na = "NA", dec = ".", row.names = F, qmethod = c("escape", "double"))

    # save table to another variable if pathway analysis
    if (params$pathway_analysis) {
        norm_counts <- vsd_names
        rownames(norm_counts) <- norm_counts$Ensembl_ID
    }
}

############################## DIAGNOSTICS AND QUALITY CONTROL PLOTS ###############################
# Cooks distances: get important for example when checking knock-out and overexpression studies
pdf("differential_gene_expression/plots/further_diagnostics_plots/Cooks-distances.pdf")
par(mar=c(10,3,3,3))
par(mfrow = c(1,2))
boxplot(log10(assays(cds)[["cooks"]]), range=0, las=2,ylim = c(-15, 15),main="log10-Cooks")
boxplot(log2(assays(cds)[["cooks"]]), range=0, las=2,ylim = c(-15, 15),main="log2-Cooks")
dev.off()
png("differential_gene_expression/plots/further_diagnostics_plots/Cooks-distances.png")
par(mar=c(10,3,3,3))
par( mfrow = c(1,2))
boxplot(log10(assays(cds)[["cooks"]]), range=0, las=2,ylim = c(-15, 15),main="log10-Cooks")
boxplot(log2(assays(cds)[["cooks"]]), range=0, las=2,ylim = c(-15, 15),main="log2-Cooks")
dev.off()
svg("differential_gene_expression/plots/further_diagnostics_plots/Cooks-distances.svg")
par(mar=c(10,3,3,3))
par( mfrow = c(1,2))
boxplot(log10(assays(cds)[["cooks"]]), range=0, las=2,ylim = c(-15, 15),main="log10-Cooks")
boxplot(log2(assays(cds)[["cooks"]]), range=0, las=2,ylim = c(-15, 15),main="log2-Cooks")
dev.off()

# The function plotDispEsts visualizes DESeqs dispersion estimates:
pdf("differential_gene_expression/plots/further_diagnostics_plots/Dispersion_plot.pdf")
plotDispEsts(cds, ylim = c(1e-5, 1e8))
dev.off()
png("differential_gene_expression/plots/further_diagnostics_plots/Dispersion_plot.png")
plotDispEsts(cds, ylim = c(1e-5, 1e8))
dev.off()
svg("differential_gene_expression/plots/further_diagnostics_plots/Dispersion_plot.svg")
plotDispEsts(cds, ylim = c(1e-5, 1e8))
dev.off()

# Effects of transformations on the variance
notAllZero <- (rowSums(counts(cds))>0)
pdf("differential_gene_expression/plots/further_diagnostics_plots/Effects_of_transformations_on_the_variance.pdf")
par(oma=c(3,3,3,3))
par(mfrow = c(1, 3))
meanSdPlot(log2(counts(cds,normalized=TRUE)[notAllZero,] + 1),ylab  = "sd raw count data")
meanSdPlot(assay((if (run_rlog) rld else vsd)[notAllZero,]),ylab  = paste("sd", norm_method_text, "transformed count data"))
dev.off()
notAllZero <- (rowSums(counts(cds))>0)
png("differential_gene_expression/plots/further_diagnostics_plots/Effects_of_transformations_on_the_variance.png")
par(oma=c(3,3,3,3))
par(mfrow = c(1, 3))
meanSdPlot(log2(counts(cds,normalized=TRUE)[notAllZero,] + 1),ylab  = "sd raw count data")
meanSdPlot(assay((if (run_rlog) rld else vsd)[notAllZero,]),ylab  = paste("sd", norm_method_text, "transformed count data"))
dev.off()
notAllZero <- (rowSums(counts(cds))>0)
svg("differential_gene_expression/plots/further_diagnostics_plots/Effects_of_transformations_on_the_variance.svg")
par(oma=c(3,3,3,3))
par(mfrow = c(1, 3))
meanSdPlot(log2(counts(cds,normalized=TRUE)[notAllZero,] + 1),ylab  = "sd raw count data")
meanSdPlot(assay((if (run_rlog) rld else vsd)[notAllZero,]),ylab  = paste("sd", norm_method_text, "transformed count data"))
dev.off()

# Further diagnostics plots
res=0
for (i in resultsNames(cds)[-1]) {
    res = results(cds,name = i)
    pdf(paste("differential_gene_expression/plots/further_diagnostics_plots/all_results_MA_plot_",i,".pdf",sep=""))
    DESeq2::plotMA(res,ylim = c(-4, 4))
    dev.off()
    png(paste("differential_gene_expression/plots/further_diagnostics_plots/all_results_MA_plot_",i,".png",sep=""))
    DESeq2::plotMA(res,ylim = c(-4, 4))
    dev.off()
    svg(paste("differential_gene_expression/plots/further_diagnostics_plots/all_results_MA_plot_",i,".svg",sep=""))
    DESeq2::plotMA(res,ylim = c(-4, 4))
    dev.off()

    # multiple hyptothesis testing
    qs <- c( 0, quantile(results(cds)$baseMean[res$baseMean > 0], 0:4/4 ))
    bins <- cut(res$baseMean, qs )

    # rename the levels of the bins using the middle point
    levels(bins) <- paste0("~",round(.5*qs[-1] + .5*qs[-length(qs)]))

    # calculate the ratio of p-values less than .01 for each bin
    ratios <- tapply(res$pvalue, bins, function(p) mean(p < .01, na.rm=TRUE ))

    # plot these ratios
    pdf(paste("differential_gene_expression/plots/further_diagnostics_plots/dependency_small.pval_mean_normal.counts_",i,".pdf",sep=""))
    barplot(ratios, xlab="mean normalized count", ylab="ratio of small p-values")
    dev.off()
    png(paste("differential_gene_expression/plots/further_diagnostics_plots/dependency_small.pval_mean_normal.counts_",i,".png",sep=""))
    barplot(ratios, xlab="mean normalized count", ylab="ratio of small p-values")
    dev.off()
    svg(paste("differential_gene_expression/plots/further_diagnostics_plots/dependency_small.pval_mean_normal.counts_",i,".svg",sep=""))
    barplot(ratios, xlab="mean normalized count", ylab="ratio of small p-values")
    dev.off()

    # plot number of rejections
    pdf(paste("differential_gene_expression/plots/further_diagnostics_plots/number.of.rejections_",i,".pdf",sep=""))
    plot(metadata(res)$filterNumRej,
        type="b", ylab="number of rejections",
        xlab="quantiles of filter")
    lines(metadata(res)$lo.fit, col="red")
    abline(v=metadata(res)$filterTheta)
    dev.off()
    png(paste("differential_gene_expression/plots/further_diagnostics_plots/number.of.rejections_",i,".png",sep=""))
    plot(metadata(res)$filterNumRej,
        type="b", ylab="number of rejections",
        xlab="quantiles of filter")
    lines(metadata(res)$lo.fit, col="red")
    abline(v=metadata(res)$filterTheta)
    dev.off()
    svg(paste("differential_gene_expression/plots/further_diagnostics_plots/number.of.rejections_",i,".svg",sep=""))
    plot(metadata(res)$filterNumRej,
        type="b", ylab="number of rejections",
        xlab="quantiles of filter")
    lines(metadata(res)$lo.fit, col="red")
    abline(v=metadata(res)$filterTheta)
    dev.off()

    # Histogram of passed and rejected hypothesis
    use <- res$baseMean > metadata(res)$filterThreshold
    table(use)
    h1 <- hist(res$pvalue[!use], breaks=0:50/50, plot=FALSE)
    h2 <- hist(res$pvalue[use], breaks=0:50/50, plot=FALSE)
    colori <- c('do not pass'="khaki", 'pass'="powderblue")
    pdf(paste("differential_gene_expression/plots/further_diagnostics_plots/histogram_of_p.values_",i,".pdf",sep=""))
    barplot(height = rbind(h1$density, h2$density), beside = FALSE,
            col = colori, space = 0, main = "", xlab="p-value",ylab="frequency")
    text(x = c(0, length(h1$counts)), y = 0, label = paste(c(0,1)),
        adj = c(0.5,1.7), xpd=NA)
    legend("topleft", fill=rev(colori), legend=rev(names(colori)))
    dev.off()
    png(paste("differential_gene_expression/plots/further_diagnostics_plots/histogram_of_p.values_",i,".png",sep=""))
    barplot(height = rbind(h1$density, h2$density), beside = FALSE,
            col = colori, space = 0, main = "", xlab="p-value",ylab="frequency")
    text(x = c(0, length(h1$counts)), y = 0, label = paste(c(0,1)),
        adj = c(0.5,1.7), xpd=NA)
    legend("topleft", fill=rev(colori), legend=rev(names(colori)))
    dev.off()
    svg(paste("differential_gene_expression/plots/further_diagnostics_plots/histogram_of_p.values_",i,".svg",sep=""))
    barplot(height = rbind(h1$density, h2$density), beside = FALSE,
            col = colori, space = 0, main = "", xlab="p-value",ylab="frequency")
    text(x = c(0, length(h1$counts)), y = 0, label = paste(c(0,1)),
        adj = c(0.5,1.7), xpd=NA)
    legend("topleft", fill=rev(colori), legend=rev(names(colori)))
    dev.off()
    rm(res,qs,bins,ratios,use,h1,h2,colori)
}
```
<!-- DESeq2 end -->


<!-- multiQC start -->

```{r summary_stats, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")), results = 'asis'}
# Check first if a new or old multiqc file was provided
if (file.exists(paste0(wd,"/QC/multiqc_data/multiqc_general_stats.txt"))) {
    mqc_stats <- read.table(file = paste0(wd,"/QC/multiqc_data/multiqc_general_stats.txt"), header=TRUE, sep="\t")
    columns <- c(
            "Sample",
            "FastQC_mqc.generalstats.fastqc.total_sequences",
            "FastQC_mqc.generalstats.fastqc.percent_duplicates",
            "FastQC_mqc.generalstats.fastqc.percent_gc",
            "Cutadapt_mqc.generalstats.cutadapt.percent_trimmed",
            "STAR_mqc.generalstats.star.uniquely_mapped_percent",
            "featureCounts_mqc.generalstats.featurecounts.percent_assigned"
        )
    if (all(columns %in% colnames(mqc_stats))) {
        mqc_version <- 'old_mqc'
    } else if (file.exists(paste0(wd,"/QC/multiqc_data/multiqc_samtools_stats.txt"))) {
        mqc_stats <- read.table(file = paste0(wd,"/QC/multiqc_data/multiqc_samtools_stats.txt"), header=TRUE, sep="\t")
        columns <- c(
                "Sample",
                "raw_total_sequences",
                "reads_mapped_percent",
                "reads_duplicated_percent"
            )
        if (all(columns %in% colnames(mqc_stats))) {
            mqc_version <- 'new_mqc'
        } else {
            stop("Could not find a suitable multiqc table; please provide a correct multiqc.zip file or omit the parameter --multiqc altogether.")
        }
    }
} else if (file.exists(paste0(wd,"/QC/multiqc_data/multiqc_samtools_stats.txt"))) {
    mqc_stats <- read.table(file = paste0(wd,"/QC/multiqc_data/multiqc_samtools_stats.txt"), header=TRUE, sep="\t")
    columns <- c(
            "Sample",
            "raw_total_sequences",
            "reads_mapped_percent",
            "reads_duplicated_percent"
        )
    if (all(columns %in% colnames(mqc_stats))) {
        mqc_version <- 'new_mqc'
    } else {
        stop("Could not find a suitable multiqc table; please provide a correct multiqc.zip file or omit the parameter --multiqc altogether.")
    }
} else {
    stop("Could not find a suitable multiqc table; please provide a correct multiqc.zip file or omit the parameter --multiqc altogether.")
}

cat(paste0("***
# Read mapping and assignment

In order to analyze the gene counts per sample, the sequencing reads need to be mapped to the reference genome, and assigned to genes or other genomic regions.
Here, the read mapping and gene assignment statistics are summarized, among other read processing quality control parameters.
The read sequencing quality was analyzed using `FASTQC`. More detailed information is available in the `MultiQC` report of all samples available [here](./QC/multiqc_report.html).

## Summary statistics

The read mapping and gene assignment statistics, together with other quality control parameters are summarized here.

The table below, extracted from the `MultiQC` report, shows a summary of the bioinformatics analysis quality control.",
ifelse(mqc_version == 'old_mqc',
"Note: Duplicate intercept (%) is the percentage of duplicate reads for the intercept of a linear model of duplicate reads vs read counts. High numbers of duplicates at low read counts can indicate low library complexity with technical duplication.",
"")
))

is.num <- sapply(mqc_stats, is.numeric)
mqc_stats[is.num] <- lapply(mqc_stats[is.num], round, 2)

# The following gets rid of multiQC entries that are spread across two rows, one ending with -fw (see https://github.com/qbic-pipelines/rnadeseq/issues/114)
mqc_stats$Sample <- gsub("-fw", "", mqc_stats$Sample) # Remove -fw to produce duplicate rows for summarising

# In newer RNASeq versions (after 1.4.2?), duplicate rows might not end with -fw, but with _1 and _2 instead; deal with those in the following lines
mqc_stats$Sample <- sub("_[0-9]+$", "", mqc_stats$Sample) # Remove _1 etc. to produce duplicate rows for summarising

# Now that the duplicate columns have been given the same names, we can group and collapse them with the appropriate functions
sum_NA <- function(x) {if (all(is.na(x))) x[NA_integer_] else sum(x, na.rm = TRUE)} # Function to sum across rows if available, else NA
avg_NA <- function(x) {if (all(is.na(x))) x[NA_integer_] else mean(x, na.rm = TRUE)} # Function to average across rows if available, else NA

if (mqc_version == 'old_mqc') {
    table_complete <- mqc_stats[,columns] %>%
        group_by(Sample) %>%
        dplyr::summarize(
            across(matches("FastQC_mqc.generalstats.fastqc.total_sequences"), sum_NA),
            across(everything(), avg_NA)
        )
} else {
    table_complete <- mqc_stats[,columns] %>%
        group_by(Sample) %>%
        dplyr::summarize(
            across(matches("raw_total_sequences"), sum_NA),
            across(everything(), avg_NA)
        )

    # For the new version, some more tables need to be read
    if (params$input_type == "salmon" && file.exists(paste0(wd,"/QC/multiqc_data/multiqc_star.txt"))) {
        star <- read.table(file = paste0(wd,"/QC/multiqc_data/multiqc_star.txt"), header=TRUE, sep="\t", check.names = F)[,c("Sample", "uniquely_mapped_percent")]
    } else if (params$input_type == "rsem" && file.exists(paste0(wd,"/QC/multiqc_data/multiqc_rsem.txt"))) {
        star <- read.table(file = paste0(wd,"/QC/multiqc_data/multiqc_rsem.txt"), header=TRUE, sep="\t", check.names = F)[,c("Sample", "Total", "Unique")]
        star$uniquely_mapped_percent <- star$Unique/star$Total
        star$Unique <- NULL
        star$Total <- NULL
    } else {
        star <- NULL
    }
    if (file.exists(paste0(wd,"/QC/multiqc_data/multiqc_cutadapt.txt"))) {
        cutadapt <- read.table(file = paste0(wd,"/QC/multiqc_data/multiqc_cutadapt.txt"), header=TRUE, sep="\t", check.names = F)[,c("Sample", "percent_trimmed")]
        cutadapt$Sample <- sub("_[0-9]+$", "", cutadapt$Sample) # Remove _1 etc. to produce duplicate rows for summarising
        cutadapt <- cutadapt %>% group_by(Sample) %>% summarise_all(avg_NA)
    } else {
        cutadapt <- NULL
    }
    if (file.exists(paste0(wd,"/QC/multiqc_data/multiqc_rseqc_read_distribution.txt"))) {
        rseqc <- read.table(file = paste0(wd,"/QC/multiqc_data/multiqc_rseqc_read_distribution.txt"), header=TRUE, sep="\t", check.names = F)[,c("Sample", "total_tags", "total_assigned_tags")]
    } else {
        rseqc <- NULL
    }
    if (file.exists(paste0(wd,"/QC/multiqc_data/multiqc_fastqc.txt"))) {
        fastqc_untrimmed <- read.table(file = paste0(wd,"/QC/multiqc_data/multiqc_fastqc.txt"), header=TRUE, sep="\t", check.names = F)[,c("Sample", "%GC")]
        colnames(fastqc_untrimmed)[colnames(fastqc_untrimmed) == "%GC"] <- "GC_untrimmed"
        fastqc_untrimmed$Sample <- sub("_[0-9]+$", "", fastqc_untrimmed$Sample) # Remove _1 etc. to produce duplicate rows for summarising
        fastqc_untrimmed <- fastqc_untrimmed %>% group_by(Sample) %>% summarise_all(avg_NA)
    } else {
        fastqc_untrimmed <- NULL
    }
    if (file.exists(paste0(wd,"/QC/multiqc_data/multiqc_fastqc_1.txt"))) {
        fastqc_trimmed <- read.table(file = paste0(wd,"/QC/multiqc_data/multiqc_fastqc_1.txt"), header=TRUE, sep="\t", check.names = F)[,c("Sample", "%GC")]
        colnames(fastqc_trimmed)[colnames(fastqc_trimmed) == "%GC"] <- "GC_trimmed"
        fastqc_trimmed$Sample <- sub("_[0-9]+$", "", fastqc_trimmed$Sample) # Remove _1 etc. to produce duplicate rows for summarising
        fastqc_trimmed <- fastqc_trimmed %>% group_by(Sample) %>% summarise_all(avg_NA)
    } else {
        fastqc_trimmed <- NULL
    }
}

if (mqc_version == 'new_mqc') {

    # Merge the additional tables into the stats
    if (!is.null(cutadapt))         table_complete <- merge(table_complete,cutadapt,by="Sample")
    if (!is.null(rseqc))            table_complete <- merge(table_complete,rseqc,by="Sample")
    if (!is.null(star))             table_complete <- merge(table_complete,star,by="Sample")
    if (!is.null(fastqc_untrimmed)) table_complete <- merge(table_complete,fastqc_untrimmed,by="Sample")
    if (!is.null(fastqc_trimmed))   table_complete <- merge(table_complete,fastqc_trimmed,by="Sample")
}

# Reduce to QBiC code
table_complete$Sample <- substr(table_complete$Sample, 1, 10)

metadata <- read.table((paste0(wd, "/differential_gene_expression/metadata/metadata.tsv")), header=TRUE, sep="\t")
metadata <- metadata[,c("QBiC.Code")]

#the following makes metadata a df again (in R, when extracting only 1 column from a df, it becomes a list)
metadata <- data.frame(matrix(unlist(metadata)))
colnames(metadata) <- c("Sample")
table_complete <- merge(metadata,table_complete,by="Sample")
if (mqc_version == 'old_mqc') {
    colnames <- c("Sample", "Number of reads (M)", "Duplicates (%)", "GC (%)", "Trimmed reads (%)", "Mapped reads (%)", "Assigned reads (%)")
    colnames(table_complete) <- c("Sample", "ReadNumber", "DuplicateReadsIntercept", "GCcontent", "TrimmedReads", "MappedReads", "AssignedReads")

    table_complete <- table_complete %>%
        mutate(
            Sample = Sample,
            ReadNumber = color_bar("lightblue")(round((ReadNumber/1000000),2)),
            DuplicateReadsIntercept = ifelse(DuplicateReadsIntercept > 1,
                                            cell_spec(DuplicateReadsIntercept, color="orange", bold=T),
                                            cell_spec(DuplicateReadsIntercept, color="black")),
            GCcontent = GCcontent,
            TrimmedReads = TrimmedReads,
            MappedReads =  ifelse(MappedReads > 80,
                                color_bar("lightblue")(MappedReads),
                                color_bar("orange")(MappedReads)),
            AssignedReads = ifelse(AssignedReads > 60,
                                color_bar("lightblue")(AssignedReads),
                                color_bar("orange")(AssignedReads))
        )
} else {
    colnames <- c("Sample", "Number of reads (M)", "Duplicates (%)", "Untrimmed GC (%)", "Trimmed GC (%)", "Trimmed reads (%)", "Mapped reads (%)", "Assigned reads (%)")

    table_complete <- table_complete %>%
        transmute(
            Sample = Sample,
            ReadNumber = color_bar("lightblue")(round((raw_total_sequences/1000000),2)),
            DuplicateReadsIntercept = ifelse(reads_duplicated_percent > 1,
                                            cell_spec(reads_duplicated_percent, color="orange", bold=T),
                                            cell_spec(reads_duplicated_percent, color="black")),
            GC_untrimmed = GC_untrimmed,
            GC_trimmed = GC_trimmed,
            TrimmedReads = percent_trimmed,
            MappedReads =  ifelse(uniquely_mapped_percent > 80,
                                color_bar("lightblue")(uniquely_mapped_percent),
                                color_bar("orange")(uniquely_mapped_percent)),
            AssignedReads = ifelse((total_assigned_tags/total_tags*100) > 60,
                                color_bar("lightblue")((total_assigned_tags/total_tags)*100),
                                color_bar("orange")((total_assigned_tags/total_tags)*100))
        )
}

# This does some final formatting of the table in the report
table_complete %>%
    kable(escape=F,row.names=F, col.names=colnames) %>%
    kable_styling("hover") %>%
    scroll_box(width = "100%", height = "400px")

cat(paste0("***
Note: Duplicate intercept (%) is the percentage of duplicate reads for the intercept of a linear model of duplicate reads vs read counts. High numbers of duplicates at low read counts can indicate low library complexity with technical duplication.

\

## Mapping statistics {.tabset}

The read mapping statistics to the reference genome for each sample are shown below. Typical values for a good mapping lie at > 80 % uniquely mapped reads.

### Percentages {-}

<center>
"))
```

```{r STAR_percentages_plot, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")), out.width="160%", dpi=1800, fig.cap="STAR: Mapping Statistics", fig.align='center'}
# Disable auto-conversion of paths to relative paths as we provide include_graphics() with absolute paths. Also, error=F is necessary in every include_graphic() call to not fail with an error
knitr.graphics.rel_path = F
knitr::include_graphics(paste0(wd, "/QC/multiqc_plots/svg/", ifelse(mqc_version == 'old_mqc',"mqc_star_alignment_plot_1_pc.svg", "mqc_samtools_alignment_plot_1_pc.svg")), error=F)
```

```{r STAR_readnums,echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/"))}
cat(paste0("***
</center>
### Number of reads {-}
<center>
"))
```

```{r STAR_readnums_plot, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")), out.width="160%", dpi=1800, fig.cap="STAR: Mapping Statistics", fig.align='center'}
knitr::include_graphics(paste0(wd, "/QC/multiqc_plots/svg/", ifelse(mqc_version == 'old_mqc',"mqc_star_alignment_plot_1.svg", "mqc_samtools_alignment_plot_1.svg")), error=F)

```

```{r FC_read_assignment, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/"))}
cat(paste0("***
</center>
\
", ifelse(mqc_version == 'old_mqc', "
## Read assignment statistics {.tabset}

The statistics of read assignment to genes are shown below. Most reads should be assigned. Interpretation of the different assignment types:

-   **Assigned:** The reads could properly be assigned to a gene or feature. \
-   **Unassigned Ambiguity:** The reads could not be assigned to any gene because of its ambiguous character.
    This can be the case when e.g. a read maps
    to two different genes at the same time making the assignment ambiguous. \
-   **Unassigned MultiMapping:** The reads could not be assigned to any gene because they map to several distinct locations on the reference genome. \
-   **Unassigned NoFeatures:** The reads could not be assigned to any gene because their mapping position in the reference genome is not annotated.

### Percentages {-}

<center>
", "
## Read assignment statistics {.tabset}

The statistics of read assignment to genes are shown below for pipeline runs on data produced by `rnaseq <= v1.4.2`. If a later version was used, these plots are not generated by rnaseq anymore. However, you can find `star/featurecounts/<sample>.featureCounts.txt.summary` or `star_salmon/featurecounts/<sample>.featureCounts.txt.summary` files in the rnaseq output folder which contain the necessary information for creating such plots.
")))
```

```{r FC_percentages_plot, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")) && mqc_version == 'old_mqc', out.width="160%", dpi=1200, fig.cap=ifelse(mqc_version == 'old_mqc', "featureCounts: Assignments", "STAR: Alignments"), fig.align='center'}
knitr::include_graphics(paste0(wd, "/QC/multiqc_plots/svg/mqc_featureCounts_assignment_plot_1_pc.svg"), error=F)
```

```{r FC_readnums, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")) && mqc_version == 'old_mqc'}
cat(paste0("***
</center>

### Number of reads {-}

<center>
"))
```

```{r FC_readnums_plot, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")) && mqc_version == 'old_mqc', out.width="160%", dpi=1200, fig.cap=ifelse(mqc_version == 'old_mqc', "featureCounts: Assignments", "STAR: Alignments"), fig.align='center'}
knitr::include_graphics(paste0(wd, "/QC/multiqc_plots/svg/mqc_featureCounts_assignment_plot_1.svg"), error=F)
```

```{r read_feat_distrib, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/"))}
cat(paste0("***
</center>
\

## Read feature distribution {.tabset}

The read distribution of mapped reads over different genomic features (CDS exon, 5'UTR exon, 3' UTR exon, Intron, Intergenic regions) is shown below.
In RNAseq experiments, the majority of the reads should be assigned to CDS exons.

### Percentages {-}

<center>
"))
```

```{r RSeqC_percentages_plot, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")), out.width="160%", dpi=1200, fig.cap="RSeQC: Read Distribution", fig.align='center'}
knitr::include_graphics(paste0(wd, "/QC/multiqc_plots/svg/mqc_rseqc_read_distribution_plot_1_pc.svg"), error=F)
```

```{r RSeqC_readnums, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/"))}
cat(paste0("***
</center>

### Number of reads {-}

<center>
"))
```

```{r RSeqC_readnums_plot, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")), out.width="160%", dpi=1200, fig.cap="RSeQC: Read Distribution", fig.align='center'}
knitr::include_graphics(paste0(wd, "/QC/multiqc_plots/svg/mqc_rseqc_read_distribution_plot_1.svg"), error=F)
```

```{r Read_strand, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/"))}
cat(paste0("***
</center>
\

## Read strandedness {.tabset}

The following plots show the number/percentage of reads that match the strandedness of overlapping transcripts. It can be used to infer whether RNA-seq library preps are stranded (sense or antisense).

<center>
"))
```

```{r Read_strandpercentages_plot, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")), out.width="160%", dpi=1200, fig.cap="RSeQC: Read Distribution", fig.align='center'}
knitr::include_graphics(paste0(wd, "/QC/multiqc_plots/svg/mqc_rseqc_infer_experiment_plot_1.svg"), error=F)
```

```{r MQC_end, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/"))}
cat(paste0("***
</center>
\
"))
```

<!-- multiQC end -->

# Gene expression data

## Raw and normalized count tables

The raw count table and normalized count tables are available [here](./differential_gene_expression/gene_counts_tables).
The differential expression analysis is performed using the raw gene count table.
For PCA analysis and heatmap plotting, the `r norm_method_long_text` normalized gene counts were used.
`r norm_method_override_text`
`r nsub_genes_text`

## Principal component analysis (PCA)

A PCA plot of the `r norm_method_text` normalized gene expression visualizes the clustering of samples according to their gene expression.
In this way, the overall effect of experimental conditions and sample grouping, and any batch effects are visualized.
The original plot can be downloaded [here](./differential_gene_expression/plots/PCA_plot.pdf).

\

```{r PCA_ifNoBatch_plot, echo=F, message=F, warning=F, out.width="80%", dpi=1200, fig.align='center'}
############################ PCA PLOTS ########################
pcaData <- plotPCA(if (run_rlog) rld else vsd,intgroup=c("combfactor"), ntop=dim(if (run_rlog) rld else vsd)[1], returnData=TRUE)
percentVar <- round(100*attr(pcaData, "percentVar"))
pca <- ggplot(pcaData, aes(PC1, PC2, color=combfactor, text=paste("Sample: ", name, "<br>", "PC1: ", PC1, "<br>", "PC2: ", PC2))) +
    geom_point(size=3) +
    xlab(paste0("PC1: ",percentVar[1],"% variance")) +
    ylab(paste0("PC2: ",percentVar[2], "% variance")) +
    coord_fixed() +
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

# Save static plot without labels
ggsave(plot = pca, filename = "differential_gene_expression/plots/PCA_plot.pdf", device = "pdf", dpi = 300)
ggsave(plot = pca, filename = "differential_gene_expression/plots/PCA_plot.svg", device = "svg", dpi = 150)
ggsave(plot = pca, filename = "differential_gene_expression/plots/PCA_plot.png", device = "png", dpi = 150)

# Save static plot with samplename labels
pca_with_labels <- pca +
    geom_label_repel(aes(label=name), force=2, force_pull=0, size=2.8, box.padding=0.15,show.legend  = F, max.overlaps=20)
ggsave(plot = pca_with_labels, filename = "differential_gene_expression/plots/PCA_plot_with_labels.pdf", device = "pdf", dpi = 300)
ggsave(plot = pca_with_labels, filename = "differential_gene_expression/plots/PCA_plot_with_labels.svg", device = "svg", dpi = 150)
ggsave(plot = pca_with_labels, filename = "differential_gene_expression/plots/PCA_plot_with_labels.png", device = "png", dpi = 150)

# Create interactive plot for report
pca <- ggplotly(pca, tooltip = "text", width=750, height=400)

# Add export-as-SVG button to plot
config(pca, modeBarButtonsToAdd = list(svg_exp)) %>% layout()

# Save non-corrected normalized object for boxplots
if (run_rlog) {
    rld_noncorrected <- rld
} else {
    vsd_noncorrected <- vsd
}
```

\

```{r batch_text, echo=F, message=F, warning=F, eval=params$batch_effect, results='asis'}
cat("Batch effects were observed in the PCA, so batch effects were corrected.
A PCA of the batch-effect corrected data is shown below and can be found [here](./differential_gene_expression/plots/PCA_batch_corrected_plot.pdf)")
```

```{r PCA_ifBatch_plot, echo=F, message=F, warning=F, dpi=1200, fig.align='center', eval=params$batch_effect}
if (run_rlog) {
    assay(rld) <- limma::removeBatchEffect(assay(rld), rld$batch)
    rld_corrected <- rld
    out_rld <- as.data.frame(assay(rld_corrected))
    out_rld <- out_rld[order(rownames(out_rld)),]
    out_rld <- cbind(Ensembl_ID = rownames(out_rld), gene_name = rld_names$gene_name, out_rld[,!names(out_rld) %in% c("gene_name")])

    write.table(out_rld, file="differential_gene_expression/gene_counts_tables/rlog_transformed_gene_counts_batchcorrected.tsv", quote=F, sep="\t", row.names=F)
} else {
    assay(vsd) <- limma::removeBatchEffect(assay(vsd), vsd$batch)
    vsd_corrected <- vsd

    out_vsd <- as.data.frame(assay(vsd_corrected))
    out_vsd <- out_vsd[order(rownames(out_vsd)),]
    out_vsd <- cbind(Ensembl_ID = rownames(out_vsd), gene_name = vsd_names$gene_name, out_vsd[,!names(out_vsd) %in% c("gene_name")])

    write.table(out_vsd, file="differential_gene_expression/gene_counts_tables/vst_transformed_gene_counts_batchcorrected.tsv", quote=F, sep="\t", row.names=F)
}
pcaData2 <- plotPCA(if (run_rlog) rld else vsd, intgroup=c("combfactor"), ntop = dim(if (run_rlog) rld else vsd)[1], returnData=TRUE)
percentVar <- round(100*attr(pcaData, "percentVar"))
pca2 <- ggplot(pcaData2, aes(PC1, PC2, color=combfactor, text=paste("Sample: ", name, "<br>", "PC1: ", PC1, "<br>", "PC2: ", PC2))) +
    geom_point(size=3)+
    xlab(paste0("PC1: ", percentVar[1],"% variance")) +
    ylab(paste0("PC2: ", percentVar[2], "% variance")) +
    coord_fixed() +
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

# Save static plot without labels
ggsave(plot = pca2, filename = "differential_gene_expression/plots/PCA_batch_corrected_plot.pdf", device = "pdf", dpi=300)
ggsave(plot = pca2, filename = "differential_gene_expression/plots/PCA_batch_corrected_plot.svg", device = "svg", dpi = 150)
ggsave(plot = pca2, filename = "differential_gene_expression/plots/PCA_batch_corrected_plot.png", device = "png", dpi = 150)

# Save static plot with samplename labels

pca2_with_labels <- pca2 +
    geom_label_repel(aes(label=name), force=2, force_pull=0, size=2.8, box.padding=0.15,show.legend  = F, max.overlaps=20)
ggsave(plot = pca2_with_labels, filename = "differential_gene_expression/plots/PCA_batch_corrected_plot_with_labels.pdf", device = "pdf", dpi = 300)
ggsave(plot = pca2_with_labels, filename = "differential_gene_expression/plots/PCA_batch_corrected_plot_with_labels.svg", device = "svg", dpi = 150)
ggsave(plot = pca2_with_labels, filename = "differential_gene_expression/plots/PCA_batch_corrected_plot_with_labels.png", device = "png", dpi = 150)

# Create interactive plot for report
pca2 <- ggplotly(pca2, tooltip = "text", width=750, height=400)

#add export-as-SVG button to plot
config(pca2, modeBarButtonsToAdd = list(svg_exp)) %>% layout()
```

## Sample distance heatmap

A sample distance heatmap was generated from the Euclidean distances of the normalized expression values for all samples.

This visualizes how similar the samples are to each other according to gene expression.
Two samples have more similar gene expression if their distance is closer to 0 (darker blue).
The original plot can be downloaded [here](./differential_gene_expression/plots/Heatmaps_of_distances.pdf).

```{r heatmap_calculate, include=FALSE}
##################  SAMPLE DISTANCES HEATMAP ##################
# Sample distances, this chunk is hidden as otherwise, the heatmap is shown multiple times
sampleDists <- dist(t(assay(if (run_rlog) rld else vsd)))
sampleDistClust <- hclust(sampleDists)  # Do clustering as input for heatmaps so that their column orders are the same
sampleDistMatrix <- as.matrix(sampleDists)
colors = colorRampPalette(rev(RColorBrewer::brewer.pal(9, "Blues")))(255)
par(oma=c(3,3,3,3))
write.table(sampleDistMatrix, file="differential_gene_expression/plots/Heatmaps_of_distances.tsv", sep="\t", quote=F)
dist_heatmap <- pheatmap(mat = sampleDistMatrix, color=colors, cluster_rows = sampleDistClust, cluster_cols = sampleDistClust)

svg("differential_gene_expression/plots/Heatmaps_of_distances.svg")
dist_heatmap
dev.off()
png("differential_gene_expression/plots/Heatmaps_of_distances.png")
dist_heatmap
dev.off()
pdf("differential_gene_expression/plots/Heatmaps_of_distances.pdf")
dist_heatmap
dev.off()

# Recompute heatmap with heatmaply for interactive plot in report
dist_heatmap <- heatmaply(sampleDistMatrix, dendrogram = "both", col = colors, grid_color = "grey", Rowv = sampleDistClust, Colv = "Rowv")
```

```{r heatmap_show, echo=FALSE, message=FALSE, warning=FALSE, out.width="90%", out.height="130%", fig.asp=1, dpi=1000, fig.align='center'}
# Add export button to plot
dist_heatmap %>% layout(height=700, width=800) %>% config(modeBarButtonsToAdd = list(svg_exp))
```

# Differential expression analysis

After unzipping the results ZIP file, the differential expression results can be found in the directory [differential_gene_expression/](./differential_gene_expression), containing the following subfolders:

```{r structure_strings, echo=FALSE, message=FALSE, warning=FALSE}

# Change the different strings depending on which input_type and transformation was used
    featurecounts_string <- ifelse(params$input_type == "featurecounts", "
    - `raw_gene_counts.txt`: raw gene counts table from the nf-core/rnaseq pipeline; used for the differential gene expression analysis.", "")
    rsem_salmon_string <- ifelse(params$input_type %in% c("rsem", "salmon"), paste0("- `star_", params$input_type, "_files.txt`: list of ", ifelse(params$input_type == "rsem", "RSEM counts files", "Salmon quantification files"), " that were provided as input; used for the differential gene expression analysis."), "")
    genecounts_string <- ifelse(run_rlog, '- `rlog_transformed_gene_counts.tsv`: normalized gene counts with the "regularized logarithm" approach. This normalization is used prior to PCA analysis and heatmap plotting of the gene counts.', '- `vst_transformed_gene_counts.tsv`: normalized gene counts with the "variance stabilizing" transformation.')
```

<br><details>
<summary>Expand/collapse</summary>
- `metadata/`
    - `metadata.tsv`: metadata sheet used by the pipeline.
    - `contrasts.tsv`: contrasts used for DE analysis (if provided).
    - `linear_model.txt`: linear model used for DE analysis.
    - `gene_list.txt`: provided list of interesting genes (if provided).
    `r rsem_salmon_string`
- `gene_counts_tables/`
    `r featurecounts_string`
    - `deseq2_library_scaled_gene_counts.tsv`: gene counts after size factor scaling.
    `r genecounts_string`
    - `sizeFactor_libraries.tsv`: size factors for each sample.
- `DE_genes_tables/`: folder containing one tab-separated table for each of the contrasts in the analysis. Each table contains a list of all differentially expressed genes in the contrast, specifying the mean gene expression across all samples (baseMean), and the log2 fold change value and p-adjusted values (padj) for this contrast.
- `final_gene_table/final_gene_list_DESeq2.tsv`: table containing a list of all genes considered in the analysis. Here a summary of the log2 Fold Change and p-adjusted values for all contrasts is displayed. Additionally, the column **filter** shows if this gene was differentially expressed (DE) in any of the contrasts, or not (not_DE). The column **contrast_vector** contains for each contrast considered in the analysis a 1 if the gene was differentially expressed for this contrast or a 0 if it was not.
- `plots/`:
    - `Heatmaps_of_distances.pdf/.png/.svg`: heatmap of the pairwise Euclidean distances among samples, when the `r norm_method_text` normalized gene counts are considered.
    - `PCA_plot.pdf`: PCA of the `r norm_method_text` normalized gene counts.
    - `boxplots_example_genes/`: boxplots of the normalized gene counts for each of the sample groups for example genes.
    - `boxplots_requested_genes/`: boxplots of the normalized gene counts for each of the sample groups for the list of requested genes.
    - `further_diagnostics_plots/`: plots for diagnostics of the differential gene analysis procedure.
</details><br>

To perform differential gene expression analysis, the gene expression data between two sample groups is compared.
These comparisons are called _contrasts_. For this analysis, the following contrasts or comparisons were made:

<!-- contrast calculation start -->
```{r contrast_calc, echo=FALSE, message=FALSE, warning=FALSE, results = 'hide'}

# Contrasts coefficient table write in metadata
coefficients <- resultsNames(cds)
coef_tab <- data.frame(coef=coefficients)
write.table(coef_tab,file="differential_gene_expression/metadata/DESeq2_coefficients.tsv", sep="\t", quote=F, col.names = T, row.names = F)

# Start variables to store DE genes for all contrasts
DE_genes_df = data.frame(DE_genes_df = character(nrow(cds)))
contrast_names <- c()
if (isProvided(params$path_contrast_matrix)){
    contrasts <- read.table(params$path_contrast_matrix, sep="\t", header = T, row.names = 1)

    # Remove batch as this should normally not be considered a contrast
    contrasts <- contrasts[!startsWith(row.names(contrasts), "batch"),]

    # to get all possible pairwise comparisons, make a combined factor
    for (c in 1:length(conditions_contrasts)) {
        if (grepl("condition_", colnames(metadata_save)[c], fixed = TRUE) && !(any(grepl(paste0("^", (colnames(metadata_save)[c])), rownames(contrasts))))) {
            conditions_contrasts[c] <- FALSE
        }
    }
    metadata_save$combfactor_contrasts <- apply(as.data.frame(metadata_save[ ,conditions_contrasts]),1,paste, collapse = "_")
    write.table(contrasts, file="differential_gene_expression/metadata/contrast_matrix.tsv", sep="\t", quote=F, col.names = T, row.names = F)

    # Check that contrast matrix is valid
    if (length(coefficients) != nrow(contrasts)){
        stop("Your contrast table has a different number of rows than the number of coefficients in the DESeq2 model.")
    }

    ## Contrast calculation for contrast matrix
    for (i in c(1:ncol(contrasts))) {
        results_DEseq_contrast <-results(cds, contrast=contrasts[[i]])
        contname <- names(contrasts[i])
        results_DEseq_contrast <- as.data.frame(results_DEseq_contrast)
        print("Analyzing contrast:")
        print(contname)

        # Add gene name in table
        DE_genes_contrast_genename <- results_DEseq_contrast
        DE_genes_contrast_genename$Ensembl_ID = row.names(results_DEseq_contrast)
        DE_genes_contrast_genename <- merge(x=DE_genes_contrast_genename, y=gene_names, by.x = "Ensembl_ID", by.y="Ensembl_ID", all.x=T)
        DE_genes_contrast_genename = DE_genes_contrast_genename[,c(dim(DE_genes_contrast_genename)[2],1:dim(DE_genes_contrast_genename)[2]-1)]
        DE_genes_contrast_genename = DE_genes_contrast_genename[order(DE_genes_contrast_genename[,"Ensembl_ID"]),]

        # Save all DE genes (even if not significant) to separate files for the volcano plot
        write.table(DE_genes_contrast_genename, file=paste("differential_gene_expression/allgenes/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)

        # Select only significantly DE
        DE_genes_contrast <- subset(DE_genes_contrast_genename, padj <= params$adj_pval_threshold & abs(log2FoldChange) >= params$logFC_threshold)
        DE_genes_contrast <- DE_genes_contrast[order(DE_genes_contrast$padj),]
        # Round table before writing
        if (isProvided(params$round_DE) && params$round_DE>-1) {
            DE_genes_contrast <- (DE_genes_contrast  %>% mutate_if(is.numeric, round, digits=params$round_DE))
        }
        # Save table
        write.table(DE_genes_contrast, file=paste("differential_gene_expression/DE_genes_tables/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)
        names(results_DEseq_contrast) = paste(names(results_DEseq_contrast),contname,sep="_")

        # Append to DE genes table for all contrasts
        DE_genes_df = cbind(DE_genes_df,results_DEseq_contrast)
    }
    contrast_names <- append(contrast_names, colnames(contrasts))
}
if (isProvided(params$path_contrast_list)) {
    contrasts <- read.table(params$path_contrast_list, sep="\t", header=T, colClasses = "character")

    # Remove batch as this should normally not be considered a contrast
    contrasts <- contrasts[!startsWith(contrasts$factor, "batch"),]

    # to get all possible pairwise comparisons, make a combined factor
    for (c in 1:length(conditions_contrasts)) {
        if (grepl("condition_", colnames(metadata_save)[c], fixed = TRUE) & !(colnames(metadata_save)[c] %in% contrasts$factor) ) {
            conditions_contrasts[c] <- FALSE
        }
    }
    metadata_save$combfactor_contrasts <- apply(as.data.frame(metadata_save[ ,conditions_contrasts]),1,paste, collapse = "_")

    for (i in 1:nrow(contrasts)) {
        if (grepl("condition_", contrasts[i,1], fixed = TRUE)) {
            cond_name <- contrasts[i,1]
            for (j in 2:ncol(contrasts)) {
                if (!any(metadata_save[cond_name]==contrasts[i,j])) {
                    stop(paste("Could not find value", contrasts[i,j], "for contrast", metadata_save[cond_name], ", please check metadata sheet and contrast list!"))
                }
            }
        }
    }
    write.table(contrasts, file="differential_gene_expression/metadata/contrast_list.tsv", quote=F)

    ## Contrast calculation for contrast list
    for (i in c(1:nrow(contrasts))) {
        cont <- as.character(contrasts[i,])
        contname <- paste0(cont[1], "_", cont[2], "_vs_", cont[3])
        results_DEseq_contrast <- results(cds, contrast=cont)
        results_DEseq_contrast <- as.data.frame(results_DEseq_contrast)
        print(contname)

        # Add gene name in table
        DE_genes_contrast_genename <- results_DEseq_contrast
        DE_genes_contrast_genename$Ensembl_ID = row.names(results_DEseq_contrast)
        DE_genes_contrast_genename <- merge(x=DE_genes_contrast_genename, y=gene_names, by.x = "Ensembl_ID", by.y="Ensembl_ID", all.x=T)
        DE_genes_contrast_genename = DE_genes_contrast_genename[,c(dim(DE_genes_contrast_genename)[2],1:dim(DE_genes_contrast_genename)[2]-1)]
        DE_genes_contrast_genename = DE_genes_contrast_genename[order(DE_genes_contrast_genename[,"Ensembl_ID"]),]

        # Save all DE genes (even if not significant) to separate files for the volcano plot
        write.table(DE_genes_contrast_genename, file=paste("differential_gene_expression/allgenes/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)

        # Select only significantly DE
        DE_genes_contrast <- subset(DE_genes_contrast_genename, padj <= params$adj_pval_threshold & abs(log2FoldChange) >= params$logFC_threshold)
        DE_genes_contrast <- DE_genes_contrast[order(DE_genes_contrast$padj),]
        # Round table before writing
        if (isProvided(params$round_DE) && params$round_DE>-1) {
            DE_genes_contrast <- (DE_genes_contrast  %>% mutate_if(is.numeric, round, digits=params$round_DE))
        }
        # Save table
        write.table(DE_genes_contrast, file=paste("differential_gene_expression/DE_genes_tables/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)
        names(results_DEseq_contrast) = paste(names(results_DEseq_contrast),contname,sep="_")

        # Append to DE genes table for all contrasts
        DE_genes_df = cbind(DE_genes_df,results_DEseq_contrast)
        contrast_names <- append(contrast_names, contname)
    }
}
if (isProvided(params$path_contrast_pairs)) {
    contrasts <- read.table(params$path_contrast_pairs, sep="\t", header = T, colClasses = "character")
    write.table(contrasts, file="differential_gene_expression/metadata/contrast_pairs.tsv", sep="\t", quote=F, col.names = T, row.names = F)

    # Contrast calculation for contrast pairs
    for (i in c(1:nrow(contrasts))) {
        cont <- as.character(contrasts[i,])
        contname <- cont[1]
        if (!(cont[2] %in% coefficients)){
            stop(paste0("Provided contrast name ", cont[2], " is invalid, it needs to be contained in ", paste(coefficients, collapse=", ")))
        }
        if (!(cont[3] %in% coefficients)){
            stop(paste0("Provided contrast name ", cont[3], " is invalid, it needs to be contained in ", paste(coefficients, collapse=", ")))
        }
        results_DEseq_contrast <- results(cds, contrast=list(cont[2],cont[3]))
        results_DEseq_contrast <- as.data.frame(results_DEseq_contrast)
        print("Analyzing contrast:")
        print(contname)

        # Add gene name in table
        DE_genes_contrast_genename <- results_DEseq_contrast
        DE_genes_contrast_genename$Ensembl_ID = row.names(results_DEseq_contrast)
        DE_genes_contrast_genename <- merge(x=DE_genes_contrast_genename, y=gene_names, by.x = "Ensembl_ID", by.y="Ensembl_ID", all.x=T)
        DE_genes_contrast_genename = DE_genes_contrast_genename[,c(dim(DE_genes_contrast_genename)[2],1:dim(DE_genes_contrast_genename)[2]-1)]
        DE_genes_contrast_genename = DE_genes_contrast_genename[order(DE_genes_contrast_genename[,"Ensembl_ID"]),]

        # Save all DE genes (even if not significant) to separate files for the volcano plot
        write.table(DE_genes_contrast_genename, file=paste("differential_gene_expression/allgenes/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)

        # Select only significantly DE
        DE_genes_contrast <-  subset(DE_genes_contrast_genename, padj <= params$adj_pval_threshold & abs(log2FoldChange) >= params$logFC_threshold)
        DE_genes_contrast <- DE_genes_contrast[order(DE_genes_contrast$padj),]

        # Round table before writing
        if (isProvided(params$round_DE) && params$round_DE>-1) {
            DE_genes_contrast <- (DE_genes_contrast  %>% mutate_if(is.numeric, round, digits=params$round_DE))
        }

        # Save table
        write.table(DE_genes_contrast, file=paste("differential_gene_expression/DE_genes_tables/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)
        names(results_DEseq_contrast) = paste(names(results_DEseq_contrast),contname,sep="_")

        # Append to DE genes table for all contrasts
        DE_genes_df = cbind(DE_genes_df,results_DEseq_contrast)
        contrast_names <- append(contrast_names, contname)
    }
}

# Calculating DE genes for default contrasts (no contrast matrix or list or pairs provided)
if (!isProvided(params$path_contrast_matrix) & !isProvided(params$path_contrast_list) & !isProvided(params$path_contrast_pairs)) {
    contrast_names <- coefficients[2:length(coefficients)]
    contrast_names <- contrast_names[!startsWith(contrast_names, "batch")]

    for (contname in contrast_names) {

        results_DEseq_contrast <- results(cds, name=contname)
        results_DEseq_contrast <- as.data.frame(results_DEseq_contrast)
        print("Analyzing contrast:")
        print(contname)

        # Adding gene name to table
        DE_genes_contrast_genename <- results_DEseq_contrast
        DE_genes_contrast_genename$Ensembl_ID = row.names(results_DEseq_contrast)
        DE_genes_contrast_genename <- merge(x=DE_genes_contrast_genename, y=gene_names, by.x ="Ensembl_ID", by.y="Ensembl_ID", all.x=T)
        DE_genes_contrast_genename = DE_genes_contrast_genename[,c(dim(DE_genes_contrast_genename)[2],1:dim(DE_genes_contrast_genename)[2]-1)]
        DE_genes_contrast_genename = DE_genes_contrast_genename[order(DE_genes_contrast_genename[,"Ensembl_ID"]),]

        # Save all DE genes (even if not significant) to separate files for the volcano plot
        write.table(DE_genes_contrast_genename, file=paste("differential_gene_expression/allgenes/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)

        # Select only significantly DE
        DE_genes_contrast <- subset(DE_genes_contrast_genename, padj <= params$adj_pval_threshold & abs(log2FoldChange) >= params$logFC_threshold)
        DE_genes_contrast <- DE_genes_contrast[order(DE_genes_contrast$padj),]
        # Round table before writing
        if (isProvided(params$round_DE) && params$round_DE>-1) {
            DE_genes_contrast <- (DE_genes_contrast  %>% mutate_if(is.numeric, round, digits=params$round_DE))
        }
        # Save table
        write.table(DE_genes_contrast, file=paste("differential_gene_expression/DE_genes_tables/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)
        names(results_DEseq_contrast) = paste(names(results_DEseq_contrast),contname,sep="_")

        # Append to DE genes table for all contrasts
        DE_genes_df = cbind(DE_genes_df,results_DEseq_contrast)
    }
}

# Write contrast names to file
write(contrast_names, file="contrast_names.txt", sep="\t")

# Remove identical columns of DE_genes_df
DE_genes_df$DE_genes_df <- NULL
idx <- duplicated(t(DE_genes_df))

# If any padj or logFC columns were marked for removal (TRUE), undo that by setting FALSE as we need these cols
idx[grepl("padj", as.character(names(idx)))] <- FALSE
idx[grepl("log2FoldChange", as.character(names(idx)))] <- FALSE

DE_genes_df <- DE_genes_df[, !idx]
DE_genes_df$Ensembl_ID <- row.names(DE_genes_df)
DE_genes_df <- DE_genes_df[,c(dim(DE_genes_df)[2],1:dim(DE_genes_df)[2]-1)]
names(DE_genes_df)[1:2] = c("Ensembl_ID","baseMean")

# Get DE genes from any contrast
padj_cols=names(DE_genes_df)[grepl("padj",names(DE_genes_df))]
logFC_cols = names(DE_genes_df)[grepl("log2FoldChange", names(DE_genes_df))]
logFC = DE_genes_df[,logFC_cols,drop=F]
padj = DE_genes_df[,padj_cols,drop=F]
padj[is.na(padj)] <- 1

# Convert to binary (1/0) matrix if padj <= params$adj_pval_threshold or not, respectively
padj_bin = data.matrix(ifelse(padj <= params$adj_pval_threshold, 1, 0))

# Convert to binary (1/0) matrix if logFC is bigger/equal or smaller/equal than threshold or not, respectively
logFC_bin = data.matrix(ifelse(abs(logFC) >= params$logFC_threshold, 1, 0))
# Multiply the two bin matrices --> if padj matrix value or LogFC matrix value is 0, will be 0

DE_bin = padj_bin * logFC_bin

# Save as data frame
DE_bin = as.data.frame(DE_bin)
cols <- names(padj)

# Contrast vector column -> contains 1 or 0 if gene was DE for each contrast
if (ncol(DE_bin)>1){
    DE_bin$contrast_vector <- apply(DE_bin[ ,cols],1,paste, collapse = "-")
    DE_bin$Ensembl_ID = row.names(padj)
} else {
    DE_bin$contrast_vector <- DE_bin[,1]
    DE_bin$Ensembl_ID = row.names(padj)
}
DE_bin = DE_bin[,c("Ensembl_ID","contrast_vector")]

# Add contrast vector to final DE genes data frame
DE_genes_final_table = merge(DE_genes_df,DE_bin,by.x="Ensembl_ID",by.y="Ensembl_ID")
stopifnot(identical(dim(DE_genes_final_table)[1],dim(assay(cds))[1]))

# Calculate outcome --> if gene is DE in any contrast, annotate as DE
DE_genes_final_table$outcome = ifelse(grepl("1",DE_genes_final_table$contrast_vector),"DE","not_DE")
DE_genes_final_table = merge(x=DE_genes_final_table, y=gene_names, by.x="Ensembl_ID", by.y="Ensembl_ID", all.x = T)
DE_genes_final_table = DE_genes_final_table[,c(dim(DE_genes_final_table)[2],1:dim(DE_genes_final_table)[2]-1)]
DE_genes_final_table = DE_genes_final_table[order(DE_genes_final_table[,"Ensembl_ID"]),]
# Round table before writing
if (isProvided(params$round_DE) && params$round_DE>-1) {
    DE_genes_final_table <- (DE_genes_final_table  %>% mutate_if(is.numeric, round, digits=params$round_DE))
}

#write to file
write.table(DE_genes_final_table, "differential_gene_expression/final_gene_table/final_DE_gene_list.tsv", append = FALSE, quote = FALSE, sep = "\t",eol = "\n", na = "NA", dec = ".", row.names = F,  col.names = T, qmethod = c("escape", "double"))
```
<!-- contrast calculation end -->

```{r print_contrasts, echo=FALSE, results='asis'}
for (i in 1:length(contrast_names)){
    cat(paste("* ", contrast_names[i], "\n"))
}
```

```{r load_config, bootstrap.show.message=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
logFC_text <- as.character(params$logFC_threshold)
pval_text <- as.character(params$adj_pval_threshold)
```

## List of differentially expressed genes

The analysis of the differential gene expression was performed using `DESeq2`.
Genes were considered differentially expressed (DE) when the adjusted p-value was equal to or lower than `r pval_text` (padj <= `r pval_text`).
Genes were further considered differentially expressed (DE) if the log2 Fold Change in expression between the two considered groups was equal to or above the threshold of `r logFC_text` in absolute terms.
The adjusted p-value is calculated in the `DESeq2` package with the Benjamini-Hochberg method. P-value adjustment
helps reduce the number of false postives (not real differentially expressed genes).

The linear model employed to model gene expression in DESeq2 was:
```{r print_model}
cat(paste(readLines(params$path_design), collapse=" "))
```

The differentially expressed genes are marked with "DE" in the outcome column if they were found
differentially expressed for any of the contrasts considered.

The table for download can be found [here](./differential_gene_expression/final_gene_table/final_DE_gene_list.tsv).

Additional tables for all individual contrasts are provided [here](./differential_gene_expression/DE_genes_tables).

## Volcano plots of DE genes {.tabset .tabset-pills}

Volcano plots display the DE genes in Log2 Fold Change values (x axis)
against their adjusted p-value (y axis) in a form of a -log10. Only DE genes are colored red.
Features were considered as differentially expressed when they exhibit a padj <= `r pval_text` (horizontal drawn through line)
and a Log2FC >= `r logFC_text` or <= -`r logFC_text` (vertical grey lines).
Here, volcano plots for all considered contrasts are shown. If a list of requested genes was provided as input,
the plot will show the label of these features of interest.
If no list of genes was provided, the plot annotates a subset of the most significant DE features with their names.
The original plots can be downloaded [here](./differential_gene_expression/plots/volcano_plots/).

```{r volcano_plot, out.width="100%", out.height="100%", eval=FALSE}

# Set plot theme
theme_set(theme_bw(base_family = "ArialMT") +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(family="ArialMT")))
allgenes_files <- list.files(path=paste0(wd, "/differential_gene_expression/allgenes/"))
table_list <- list()

#Use allgenes files for volcano plots to also show non-DE genes
for (file in allgenes_files){

    #Reading DE genes list
    fname <- tools::file_path_sans_ext(basename(file))
    DE_genes <- read.csv(file = paste0(wd, "/differential_gene_expression/allgenes/", file), sep="\t", header = T)
    DE_genes$contrast <- rep(fname, nrow(DE_genes))

    # label: gene_name
    # x: log2FoldChange
    # y: -log10(padj)
    table_list <- append(table_list, list(DE_genes))
}
DE_all <- ldply(table_list, rbind)
DE_all$logpval <- -log10(DE_all$padj)
DE_all$truelogpval <- DE_all$logpval # Save true value for hovertext
DE_all$logpval[DE_all$logpval > 16] <- 17
DE_all <- na.omit(DE_all)
DE_all <- DE_all %>% mutate(color = ifelse(abs(DE_all$log2FoldChange) >= params$logFC_threshold & DE_all$logpval >= -log10(params$adj_pval_threshold), "red", "black")) # Create column which assigns each entry a plot color so that coloring is consistent even when no DE genes are found
log2FoldChange_min <- min(DE_all$log2FoldChange)
log2FoldChange_max <- max(DE_all$log2FoldChange)

# get quotient of log2FoldChange range and 10 to determine if xticks of plot need to be scaled discretely (otherwise, for large FC ranges, there will be too many xticks and they will overlap)
log2FoldChange_quotient <- length(seq(log2FoldChange_min, log2FoldChange_max, 10))

pg <- ggplot(DE_all, aes(x=log2FoldChange, y=logpval, text=paste("Gene: ", gene_name,
                                                                    "<br>", "Log2FC: ", formatC(log2FoldChange, digits=2),
                                                                    "<br>", "-Log10padj: ", formatC(truelogpval, digits=2)))) +
        geom_point(alpha=0.5, width = 0.2, aes(color=ifelse(DE_all$color == "red", "Differentially expressed genes", "Non-differentially expressed genes"))) +
        geom_hline(yintercept = 16, linetype= "dashed", size = 0.2, color = "grey") +
        geom_hline(yintercept = -log10(params$adj_pval_threshold), size = 0.2, color = "grey") +
        geom_vline(xintercept = -params$logFC_threshold, size = 0.2, color = "grey") +
        geom_vline(xintercept = params$logFC_threshold, size = 0.2, color = "grey") +
        scale_color_manual(name = "", values=c("red", "black")) +
        scale_y_continuous(limits = c(1, 18)) +
        facet_wrap(~contrast, ncol=1, scales = "free_x", shrink = FALSE) +
        ylab("-log 10 padj") + xlab("Log2 Fold Change") +
        theme(panel.spacing = unit(ifelse(length(allgenes_files)>2, 0.1, 0.6), "lines")) +
        scale_x_continuous(breaks = seq(-200, 200, ifelse(log2FoldChange_quotient<3, 1, 5)))

pg <- ggplotly(pg, tooltip = "text")
pg[['x']][['layout']][['annotations']][[2]][['x']] <- -0.05 # These lines add a bit of additional space between the x/y axis labels and the plot
pg[['x']][['layout']][['annotations']][[1]][['y']] <- -0.05

#add export button to plot
config(pg, modeBarButtonsToAdd = list(svg_exp)) %>% layout(margin = list(l=80, b = ifelse(length(allgenes_files)>2, 150, 100)), width=700, height = 500*length(allgenes_files))
```


```{r enhanced_volcano, echo=FALSE, message=FALSE, warning=FALSE}

library(EnhancedVolcano)
library(ggplot2)

theme_set(theme_bw(base_family = "ArialMT") +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(family="ArialMT")))


thousandFormat <- function(x){
    formatC(x, format='f', big.mark=',', digits=0)
}

allgenes_files <- list.files(path=paste0(wd, "/differential_gene_expression/allgenes/"))
volcano_list <-  c()
contrast_list <- c()


for (file in allgenes_files){

    # Reading DE genes list
    fname <- tools::file_path_sans_ext(basename(file))
    DE_genes <- read.csv(file = paste0(wd, "/differential_gene_expression/allgenes/", file), sep="\t", header = T)
    DE_genes$contrast <- rep(fname, nrow(DE_genes))
    contrast_len <- sapply(strsplit(fname, '_'), length)
    # Rename Contrast for plot
    # DE_contrast_condition_conditionName_conditionA_vs_conditionB --> conditionA vs conditionB
    contrast_list <- c(contrast_list, sapply(strsplit(fname, '_'), function(x) paste(x[5:contrast_len], collapse=' ')))

    # label: gene_name
    # x: log2FoldChange
    # y: -log10(padj)

    DE_genes <- na.omit(DE_genes)

    # convert zeros to small value (as in EnhancedVolcano)
    DE_genes[which(DE_genes[['padj']] == 0), 'padj'] <- min(DE_genes[which(DE_genes[['padj']] != 0), 'padj'], na.rm = TRUE) * 10^-1

    # Get Number of DE features
    numDE <- DE_genes %>%
        filter(padj <= params$adj_pval_threshold, abs(log2FoldChange) >= params$logFC_threshold) %>%
        nrow()

    # Plot old volcano version static and save
    DE_genes$logpval <- -log10(DE_genes$padj)
    # Save true value for hovertext
    DE_genes$truelogpval <- DE_genes$logpval
    DE_genes <- DE_genes %>%
            mutate(color = ifelse((abs(DE_genes$log2FoldChange) >= params$logFC_threshold & DE_genes$logpval >= -log10(params$adj_pval_threshold)), "red",
            ifelse((abs(DE_genes$log2FoldChange) < params$logFC_threshold & DE_genes$logpval >= -log10(params$adj_pval_threshold)), "green",
                ifelse((abs(DE_genes$log2FoldChange) >= params$logFC_threshold & DE_genes$logpval <= -log10(params$adj_pval_threshold)), "blue",
                    ifelse((abs(DE_genes$log2FoldChange) < params$logFC_threshold & DE_genes$logpval < -log10(params$adj_pval_threshold)), "black", "purple")
                        )
                    )
                )
            )
    log2FoldChange_min <- min(DE_genes$log2FoldChange)
    log2FoldChange_max <- max(DE_genes$log2FoldChange)
    log2FoldChange_quotient <- length(seq(log2FoldChange_min, log2FoldChange_max, 10))

    pg <- ggplot(
            DE_genes,
            aes(
                x=log2FoldChange,
                y=logpval,
                text=paste("Gene: ", gene_name,
                            "<br>", "Log2FC: ", formatC(log2FoldChange, digits=2),
                            "<br>", "-Log10padj: ", formatC(truelogpval, digits=2, format='f')))) +
            geom_point(
            alpha = 0.5, aes(colour = ifelse(color == "red", "DE features",
                ifelse(color == "green", paste("padj<", params$adj_pval_threshold),
                ifelse(color == "blue", paste("log2FC>", params$logFC_threshold),
                    ifelse(color == "black", "Non-DE features", "")
                )
                )
            )),
            na.rm = TRUE
            ) +
            geom_hline(yintercept = -log10(params$adj_pval_threshold), linewidth = 0.2, color = "grey") +
            geom_vline(xintercept = -1, linewidth = 0.2, color = "grey") +
            geom_vline(xintercept = 1, linewidth = 0.2, color = "grey") +
            scale_color_manual(name = "", values = c("red", "blue", "black", "green")) +
            scale_y_continuous(limits = c(-1, max(-log10(DE_genes[['padj']]), na.rm=TRUE) + 5)) +
            ylab("-log 10 padj") + xlab("Log2 Fold Change") +
            theme(panel.spacing = unit(ifelse(length(allgenes_files)>2, 0.1, 0.6), "lines")) +
            scale_x_continuous(breaks = seq(-200, 200, ifelse(log2FoldChange_quotient<3, 1, 5))) +
            ggtitle(
                paste("DE results", DE_genes$contrast[1]),
                subtitle=paste0("total=", thousandFormat(nrow(DE_genes)), ", DE_features=", thousandFormat(numDE)))


    # Save static plot
    ggsave(
        filename = file.path(wd, "/differential_gene_expression", "plots", "volcano_plots", paste0(fname, ".png")),
        plot = pg,
        width = 8,
        height = 5)

    # Define smaller plotly size
    ppg <- partial_bundle(ggplotly(pg, tooltip = "text")) %>% layout(autosize = F, width = 600, height = 400)

    # Export interactive plot
    saveWidget(ppg, file = file.path(wd, "/differential_gene_expression", "plots", "volcano_plots", paste0(fname, ".html")))

    # If a list of genes is provided, label only those in plot
    if (isProvided(params$path_genelist)) {
        requested_genes <- read.table(params$path_genelist, col.names = "gene_name")
        requested_genes <- sapply(as.vector(requested_genes$gene_name), toupper)
        DE_genes$GENE_NAME <- sapply(DE_genes$gene_name, toupper)
        genes_to_label <- requested_genes[requested_genes %in% DE_genes$GENE_NAME]

        # Enhanced volcano plot
        p <- EnhancedVolcano(DE_genes,
                    lab = DE_genes$GENE_NAME,
                    x = 'log2FoldChange',
                    y = 'padj',
                    selectLab = as.list(genes_to_label),
                    pCutoff = 5e-2,
                    legendLabSize = 10,
                    legendLabels = c("NS", paste0("Log2FC >|", params$logFC_threshold, "|"),
                                    paste0("p_adj<", params$adj_pval_threshold),
                                    paste0("DE:", "p_adj<", params$adj_pval_threshold, " & Log2FC >|", params$logFC_threshold, "|")),
                    title = paste('Differential expression'),
                    subtitle = DE_genes$contrast,
                    caption = bquote(
                        "total=" ~ .(paste0(thousandFormat(nrow(DE_genes)), " features")) *
                        ", DE features=" ~ .(paste0(thousandFormat(numDE)))
                        )
                    )

        p <- p + theme(plot.caption = element_text(hjust = 1))
        ggsave(
            filename = file.path(wd, "differential_gene_expression", "plots", "volcano_plots", paste0(fname, "_enhanced.png")),
            plot = p,
            width = 9,
            height = 8)

        # Save enhanced plots into list
        volcano_list[[length(volcano_list) + 1]] <- p


    # If no list of genes of interest is provided, label significant features
    } else if (!isProvided(params$path_genelist))  {
        # Enhanced volcano plot
        p <- EnhancedVolcano(DE_genes,
                    lab = DE_genes$gene_name,
                    x = 'log2FoldChange',
                    y = 'padj',
                    pCutoff = 5e-2,
                    legendLabSize = 10,
                    legendLabels = c("NS", paste0("Log2FC >|", params$logFC_threshold, "|"),
                                    paste0("p_adj<", params$adj_pval_threshold),
                                    paste0("DE:", "p_adj<", params$adj_pval_threshold, " & Log2FC >|", params$logFC_threshold, "|")),
                    title = paste('Differential expression'),
                    subtitle = DE_genes$contrast,
                    caption = bquote(
                        "total=" ~ .(paste0(thousandFormat(nrow(DE_genes)), " features")) *
                        ", DE features=" ~ .(paste0(thousandFormat(numDE)))
                        )
                    )

        p <- p + theme(plot.caption = element_text(hjust = 1))
        ggsave(
            filename = file.path(wd, "differential_gene_expression", "plots", "volcano_plots", paste0(fname, "_enhanced.png")),
            plot = p,
            width = 9,
            height = 8)

        # Save enhanced plots into list
        volcano_list[[length(volcano_list) + 1]] <- p

        }

    }

```


<!-- Display volcano plots in report in tabs -->

```{r show_enhanced_volcano, results = 'asis', fig.height=7, fig.width=7, message=FALSE, warning=FALSE}

# Show the volcano plots in tabs
for (i in 1:length(volcano_list)){
    cat("### Contrast: ", contrast_list[[i]], "\n")
    cat("\n")
    print(volcano_list[[i]])
    cat("\n\n")
}

```



```{r box_plots_noBatch, echo=F, message=F}
# Decide which object to use for boxplots without batch correction
if (run_rlog) {
    box_object <- rld_noncorrected
} else {
    box_object <- vsd_noncorrected
}

############### BOXPLOTS GENE EXPRESSION PER CONDITION ##########################
# extract ID for genes to plot, make 20 plots:
DE_genes_plot <- subset(DE_genes_final_table, outcome == "DE")
DE_genes_plot = unique(DE_genes_plot[c("Ensembl_ID", "gene_name")])
if (length(DE_genes_plot) > 20) {
    random_DE_genes_plot = sample(DE_genes_plot,size = 2)
} else {
    random_DE_genes_plot = DE_genes_plot
}

colData(box_object)$combfactor_contrasts <- apply(as.data.frame(metadata_save[ ,conditions_contrasts]),1,paste, collapse = "_")

# Previously, the function plotCounts was used here before ggplot. In PR #215, this was changed in order to allow for plotting the rlog/vst-normalized counts before/after batch correction (plotCounts can only do a normalization by sizeFactors). This was done following the instructions here: https://support.bioconductor.org/p/68859/
# 1. Get columns from coldata
box_df <-  data.frame(colData(box_object))
for (i in nrow(random_DE_genes_plot)) {
    ensid <- random_DE_genes_plot$Ensembl_ID[i]
    genename <- random_DE_genes_plot$gene_name[i]

    # 2. Get 1 column from assay; this column will correspond to the target gene
    box_df$count <- assay(box_object)[ensid,]
    plot <- ggplot(data=box_df, aes(x=combfactor_contrasts, y=count, fill=combfactor_contrasts)) +
                geom_boxplot(position=position_dodge()) +
                geom_jitter(position=position_dodge(.8)) +
                ggtitle(paste0("Gene ",genename,"/",ensid)) + xlab("") + ylab(paste0(ifelse(run_rlog, "rlog", "vst"), "-normalized gene counts")) + theme_bw() +
                theme(text = element_text(size=12),
                axis.text.x = element_text(angle=45, vjust=1,hjust=1))
    ggsave(filename=paste0("differential_gene_expression/plots/boxplots_example_genes/",genename,"_",ensid,".svg"), width=10, height=5, plot=plot)
    ggsave(filename=paste0("differential_gene_expression/plots/boxplots_example_genes/",genename,"_",ensid,".png"), width=10, height=5, plot=plot)
    ggsave(filename=paste0("differential_gene_expression/plots/boxplots_example_genes/",genename,"_",ensid,".pdf"), width=10, height=5, plot=plot)
}

# make boxplots of interesting genes in gene list
if (isProvided(params$path_genelist)) {
    gene_ids <- read.table(params$path_genelist, col.names = "requested_gene_name")
    write.table(gene_ids, file="differential_gene_expression/metadata/requested_gene_list.txt", col.names=F, row.names=F, sep="\t")
    gene_ids$requested_gene_name <- sapply(gene_ids$requested_gene_name, toupper)
    gene_names$gene_name <- sapply(gene_names$gene_name, toupper)

    # get Ensemble IDs from requested genes
    requested_genes_plot <- subset(gene_names, gene_name %in% gene_ids$requested_gene_name)

    # Check that genes are in the box_object table
    requested_genes_plot <- subset(requested_genes_plot, requested_genes_plot$Ensembl_ID %in% row.names(box_object))
    requested_genes_plot_Ensembl <- requested_genes_plot$Ensembl_ID
    requested_genes_plot_gene_name <- requested_genes_plot$gene_name

    for (i in seq_along(requested_genes_plot_Ensembl)) {

        # As above
        box_df$count <- assay(box_object)[requested_genes_plot_Ensembl[i],]
        plot <- ggplot(data=box_df, aes(x=combfactor_contrasts, y=count, fill=combfactor_contrasts)) +
                    geom_boxplot(position=position_dodge()) +
                    geom_jitter(position=position_dodge(.8)) +
                    ggtitle(paste0("Gene ",requested_genes_plot_gene_name[i],"/",requested_genes_plot_Ensembl[i])) + xlab("") + ylab(paste0(ifelse(run_rlog, "rlog", "vst"), "-normalized gene counts")) + theme_bw() +
                    theme(text = element_text(size=12),
                    axis.text.x = element_text(angle=45, vjust=1,hjust=1))
        ggsave(filename=paste("differential_gene_expression/plots/boxplots_requested_genes/",requested_genes_plot_gene_name[i],"_",requested_genes_plot_Ensembl[i],".svg",sep=""), width=10, height=5, plot=plot)
        ggsave(filename=paste("differential_gene_expression/plots/boxplots_requested_genes/",requested_genes_plot_gene_name[i],"_",requested_genes_plot_Ensembl[i],".png",sep=""), width=10, height=5, plot=plot)
        ggsave(filename=paste("differential_gene_expression/plots/boxplots_requested_genes/",requested_genes_plot_gene_name[i],"_",requested_genes_plot_Ensembl[i],".pdf",sep=""), width=10, height=5, plot=plot)
    }
}
```

```{r box_plots_Batch, echo=F, message=F, eval=params$batch_effect}
# Decide which object to use for boxplots without batch correction
if (run_rlog) {
    box_object <- rld_corrected
} else {
    box_object <- vsd_corrected
}

############### BOXPLOTS GENE EXPRESSION PER CONDITION ##########################


colData(box_object)$combfactor_contrasts <- apply(as.data.frame(metadata_save[ ,conditions_contrasts]),1,paste, collapse = "_")

# Previously, the function plotCounts was used here before ggplot. In PR #215, this was changed in order to allow for plotting the rlog/vst-normalized counts before/after batch correction (plotCounts can only do a normalization by sizeFactors). This was done following the instructions here: https://support.bioconductor.org/p/68859/
# 1. Get columns from coldata
box_df <-  data.frame(colData(box_object))

for (i in nrow(random_DE_genes_plot)) {
    ensid <- random_DE_genes_plot$Ensembl_ID[i]
    genename <- random_DE_genes_plot$gene_name[i]


    # 2. Get 1 column from assay; this column will correspond to the target gene
    box_df$count <- assay(box_object)[ensid,]
    plot <- ggplot(data=box_df, aes(x=combfactor_contrasts, y=count, fill=combfactor_contrasts)) +
                geom_boxplot(position=position_dodge()) +
                geom_jitter(position=position_dodge(.8)) +
                ggtitle(paste0("Gene ",genename,"/",ensid)) + xlab("") + ylab(paste0(ifelse(run_rlog, "rlog", "vst"), "-normalized gene counts")) + theme_bw() +
                theme(text = element_text(size=12),
                axis.text.x = element_text(angle=45, vjust=1,hjust=1))
    ggsave(filename=paste0("differential_gene_expression/plots/boxplots_example_genes/",genename,"_",ensid,"_after_batchcorrect.svg"), width=10, height=5, plot=plot)
    ggsave(filename=paste0("differential_gene_expression/plots/boxplots_example_genes/",genename,"_",ensid,"_after_batchcorrect.png"), width=10, height=5, plot=plot)
    ggsave(filename=paste0("differential_gene_expression/plots/boxplots_example_genes/",genename,"_",ensid,"_after_batchcorrect.pdf"), width=10, height=5, plot=plot)
}

# make boxplots of interesting genes in gene list
if (isProvided(params$path_genelist)) {
    gene_ids <- read.table(params$path_genelist, col.names = "requested_gene_name")
    write.table(gene_ids, file="differential_gene_expression/metadata/requested_gene_list.txt", col.names=F, row.names=F, sep="\t", quote=F)
    gene_ids$requested_gene_name <- sapply(gene_ids$requested_gene_name, toupper)
    gene_names$gene_name <- sapply(gene_names$gene_name, toupper)

    # get Ensemble IDs from requested genes
    requested_genes_plot <- subset(gene_names, gene_name %in% gene_ids$requested_gene_name)

    # Check that genes are in the box_object table
    requested_genes_plot <- subset(requested_genes_plot, requested_genes_plot$Ensembl_ID %in% row.names(box_object))
    requested_genes_plot_Ensembl <- requested_genes_plot$Ensembl_ID
    requested_genes_plot_gene_name <- requested_genes_plot$gene_name

    for (i in seq_along(requested_genes_plot_Ensembl)) {

        # As above
        box_df$count <- assay(box_object)[requested_genes_plot_Ensembl[i],]
        plot <- ggplot(data=box_df, aes(x=combfactor_contrasts, y=count, fill=combfactor_contrasts)) +
                    geom_boxplot(position=position_dodge()) +
                    geom_jitter(position=position_dodge(.8)) +
                    ggtitle(paste0("Gene ",requested_genes_plot_gene_name[i],"/",requested_genes_plot_Ensembl[i])) + xlab("") + ylab(paste0(ifelse(run_rlog, "rlog", "vst"), "-normalized gene counts")) + theme_bw() +
                    theme(text = element_text(size=12),
                    axis.text.x = element_text(angle=45, vjust=1,hjust=1))
        ggsave(filename=paste0("differential_gene_expression/plots/boxplots_requested_genes/",requested_genes_plot_gene_name[i],"_",requested_genes_plot_Ensembl[i],"_after_batchcorrect.svg"), width=10, height=5, plot=plot)
        ggsave(filename=paste0("differential_gene_expression/plots/boxplots_requested_genes/",requested_genes_plot_gene_name[i],"_",requested_genes_plot_Ensembl[i],"_after_batchcorrect.png"), width=10, height=5, plot=plot)
        ggsave(filename=paste0("differential_gene_expression/plots/boxplots_requested_genes/",requested_genes_plot_gene_name[i],"_",requested_genes_plot_Ensembl[i],"_after_batchcorrect.pdf"), width=10, height=5, plot=plot)
    }
}
```

## Boxplots of gene normalized counts

Plots of the normalized counts were generated for some example genes. Count normalization was performed by
sequencing depth and adding a pseudocount of 1/2 to allow for log scale plotting.
The plots are available at [boxplots_example_genes](./differential_gene_expression/plots/boxplots_example_genes).

```{r setup3, echo=FALSE, message=FALSE, bootstrap.show.message=FALSE, include=FALSE}
gene=FALSE
df_gene <- try(read.table(params$path_genelist))
if (!inherits(df_gene, 'try-error')){
    names = rownames(df_gene)
    gene = TRUE
}
```

```{r genes_block, echo=FALSE, results='asis', eval=gene}
cat("Plots for the [genes of interest](./differential_gene_expression/metadata/gene_list.txt) can be found [here](./differential_gene_expression/plots/boxplots_requested_genes/).
\
")
```

<!-- In case KEGG analysis was also included; differentiating the cases with and without contrasts -->

<!-- PA start -->
```{r load_PA_libs, eval=params$pathway_analysis, echo=FALSE, message=FALSE, warning=FALSE, results = 'hide'}

# Load libs invisibly
invisible(lapply(c(
"gprofiler2",
"reshape2",
"pathview",
"AnnotationDbi",
"optparse",
"ggvenn"
), library, character.only=T))

# Create output directory
dir.create("pathway_analysis")

#The following installs the necessary species library
species_dir <- tempdir()
organism <- tolower(params$organism)
short_organism_name <- substr(organism,1,3)
if (!require("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}
BiocManager::install(params$species_library, lib=species_dir, version="3.17", force=T)
library(params$species_library, lib.loc=species_dir, character.only=T)
species_library_installed <- get(params$species_library)

# If provided, prepare datasources from comma-separated string
if (isProvided(params$datasources)) {
    datasources <- unlist(strsplit(params$datasources, ','))
} else {
    datasources <- c()
}

# Default to 1 for the nb of genes DE in a pathway
min_DEG_pathway <- as.integer(params$min_DEG_pathway)

# If background list is to be used, load custom background list
# if provided, else use notAllZero -->then save to output
if (isProvided(params$set_background)) {
    if (isProvided(params$custom_background)) {
        custom_background <- readLines(params$custom_background)
    } else {
        custom_background <- rownames(counts(cds))[notAllZero]
    }
    dir.create("pathway_analysis/metadata")
    write.table(custom_background, "pathway_analysis/metadata/custom_background.txt", quote=F, row.names = F, col.names = F)
}

# Contrast files
contrast_files <- list.files('differential_gene_expression/DE_genes_tables/')
path_contrasts <- 'differential_gene_expression/DE_genes_tables/'

# Reading metadata table
metadata <- metadata_PA
metadata$Secondary.Name <- gsub(" ; ", "_", metadata$Secondary.Name) # Remove blank spaces and ; from secondary name
metadata$Secondary.Name <- gsub(" ", "_", metadata$Secondary.Name) # Remove blank spaces if there from secondary name

#This saves whether a GMT file is present and should be moved to the pathway_analysis/metadata folder; initialize as FALSE
mv_status <- F

if (isProvided(params$custom_gmt)){

    # If custom GMT file was provided, filter it before uploading to use in gost queries (gprofiler will NOT filter itself, so otherwise the output will contain all kinds of datasources, not just the selected ones)
    out_gmt <- readLines(params$custom_gmt)

    # If datasources are also provided, filter the GMT
    if (isProvided(params$datasources)) {
        go_positions <- grep("^GO", datasources)
        if (length(go_positions)) {
            datasources <- my_vector[-go_positions]     # If there are any datasources starting with GO, remove them (gets rid of GO:BP etc.)
            datasources <- append(datasources, "GO")    # Then add the single entry GO, as otherwise, the filtering might not recognize these datasources
        }
        out_gmt <- (Filter(function(line) any(startsWith(line, datasources)), out_gmt)) # Remove GMT lines that don't start with a datasource
    }

    out_path <- paste0(tools::file_path_sans_ext(basename(params$custom_gmt)), "_filtered.gmt")
    writeLines(out_gmt, out_path)
    gost_id <- upload_GMT_file(out_path)
    mv_status <- T
} else {

    # Otherwise, get the GMT file from gprofiler and save both the full file as well as the filtered one to metadata
    gost_id <- organism
    gmt_url <- paste0("https://biit.cs.ut.ee/gprofiler//static/gprofiler_full_", organism, ".ENSG.gmt")
    tryCatch(
        {
            wget_command <- paste0("wget ", gmt_url)
            sys_return <- system(wget_command)
            if (sys_return == 0 || "saved" %in% sys_return) {
                mv_status <- T
            } else {
                print("Failed to fetch the GMT file from gprofiler with this URL:")
                print(gmt_url)
                print("For reproducibility reasons, try to download the GMT file manually by visiting https://biit.cs.ut.ee/gprofiler/gost, then selecting the correct organism and finally, in datasources, clicking 'combined ENSG.gmt'.")
            }
        },
        error=function(gost_error) {
            print("Failed to fetch the GMT file from gprofiler with this URL:")
            print(gmt_url)
            print("Got error:")
            print(gost_error)
            print("For reproducibility reasons, please try to download the GMT file manually by visiting https://biit.cs.ut.ee/gprofiler/gost, then selecting the correct organism and finally, in datasources, clicking 'combined ENSG.gmt'. Then provide it to the pipeline with the parameter `--custom_gmt`")
        }
    )
}

# If GMT exist(s), create metadata folder and move GMT(s) there

if (mv_status) {
    dir.create("pathway_analysis/metadata")
    system("mv *.gmt pathway_analysis/metadata")
    if (isProvided(params$custom_gmt)) {
        system(paste("cp", params$custom_gmt, "pathway_analysis/metadata/"))
    }
}

# Set datasources to NULL instead of c() to ensure that the gost queries work
if (!isProvided(params$datasources)) {
    datasources <- NULL
}

# ------------------
# Set default params
# ------------------
pathway_pval_text <- format(params$pathway_adj_pval_threshold, scientific=F)

# Set theme for graphs
theme_set(theme_classic())

# ----------------------
# Start pathway analysis
# ----------------------

# For each contrast do pathway analysis

for (file in contrast_files){

    # Read DE genes list
    fname <- tools::file_path_sans_ext(basename(file))

    dir.create(paste("pathway_analysis", fname, sep="/"))
    dir.create(paste("pathway_analysis", fname, "KEGG_pathways", sep="/"))
    dir.create(paste("pathway_analysis", fname, "enrichment_plots", sep="/"))
    DE_genes <- read.csv(file = paste0(path_contrasts, file), sep="\t", header = T)
    DE_genes <- as.data.frame(DE_genes)

    # Skip pathway analysis for the contrast if not 2 or more DE genes were found
    if (nrow(DE_genes) < 2){
        print(paste0("Not enough DE genes to allow for a pathway analysis for contrast: ", fname))
        next
    }

    # Define list of Ensemble IDs (q) to run the pathway analysis
    q = as.character(DE_genes$Ensembl_ID)

    # gost query
    if (isProvided(params$set_background)) {
        gostres <- gost(query=q,
            organism=gost_id,
            significant=T,
            correction_method="fdr",
            sources=datasources,
            evcodes=TRUE,
            user_threshold=params$pathway_adj_pval_threshold,
            custom_bg=custom_background,
            domain_scope="custom_annotated"
        )

        pathway_gostres <- gostres$result
        pathway_gostres <- as.data.frame(pathway_gostres[which(pathway_gostres$significant==TRUE),])
        pathway_gostres <- pathway_gostres[which(pathway_gostres$intersection_size>=min_DEG_pathway),]

        # Also run without bg for Venn diagrams
        gostres_nobg <- gost(query=q,
            organism=gost_id,
            significant=T,
            correction_method="fdr",
            sources=datasources,
            evcodes=TRUE,
            user_threshold=params$pathway_adj_pval_threshold,
            domain_scope="annotated"
        )
        pathway_gostres_nobg <- gostres_nobg$result
        pathway_gostres_nobg <- as.data.frame(pathway_gostres_nobg[which(pathway_gostres_nobg$significant==TRUE),])
        pathway_gostres_nobg <- pathway_gostres_nobg[which(pathway_gostres_nobg$intersection_size>=min_DEG_pathway),]

    } else {
        gostres <- gost(query=q,
            organism=gost_id,
            significant=T,
            correction_method="fdr",
            sources=datasources,
            evcodes=TRUE,
            user_threshold=params$pathway_adj_pval_threshold,
            domain_scope="annotated"
        )
    }

    # Make data frame of gost result
    pathway_gostres <- gostres$result

    # Select only significantly enriched pathways (according to adjusted p-value)
    pathway_gostres <- as.data.frame(pathway_gostres[which(pathway_gostres$significant==TRUE),])

    # Select only pathways with a min. number of DEG
    pathway_gostres <- pathway_gostres[which(pathway_gostres$intersection_size>=min_DEG_pathway),]
    gostres$result <- pathway_gostres

    # Plot pathways if there were any
    if (nrow(pathway_gostres) > 0){

        # annotate query size (number of DE genes in contrast)
        pathway_gostres$original_query_size <- rep(length(q), nrow(pathway_gostres))

        # Generate non-interactive pathway dotplots in the folder
        pg <- gostplot(gostres, capped=T, interactive=F)
        ggsave(pg, filename = paste0("pathway_analysis/", "/", fname, "/gost_pathway_gostplot.pdf"),
            device="pdf",
            height=10, width=15, units="cm", limitsize=F)
        ggsave(pg, filename = paste0("pathway_analysis/", "/", fname, "/gost_pathway_gostplot.png"),
            device="png",
            height=10, width=15, units="cm", dpi=300, limitsize=F)
        ggsave(pg, filename = paste0("pathway_analysis/", "/", fname, "/gost_pathway_gostplot.svg"),
            device="svg",
            height=10, width=15, units="cm", dpi=300, limitsize=F)

        # If background list was used for main PA analysis, plot Venn diagram of the results and those from the additional PA without background list
        if (isProvided(params$set_background)) {
            pathway_gostres_nobg <- gostres_nobg$result
            pathway_gostres_nobg <- as.data.frame(pathway_gostres_nobg[which(pathway_gostres_nobg$significant==TRUE),])
            pathway_gostres_nobg <- pathway_gostres_nobg[which(pathway_gostres_nobg$intersection_size>=min_DEG_pathway),]
            VennInput <- list(
                background=pathway_gostres$term_name,
                no_background=pathway_gostres_nobg$term_name
            )
            pv <- ggvenn::ggvenn(VennInput)
            ggsave(paste0("pathway_analysis", "/", fname, "/gost_pathway_venn_diagram.pdf"),pv, device="pdf", width=10, height=15)
            ggsave(paste0("pathway_analysis", "/", fname, "/gost_pathway_venn_diagram.png"),pv, device="png", width=10, height=15)
            ggsave(paste0("pathway_analysis", "/", fname, "/gost_pathway_venn_diagram.svg"),pv, device="svg", width=10, height=15)
        }
    }

    # Remove parents column to be able to save the table in tsv format
    pathway_gostres_table <- pathway_gostres
    pathway_gostres_table$parents <- NULL

    # Save pathway enrichment table in tsv format
    write.table(pathway_gostres_table,
                file = paste0("pathway_analysis", "/", fname, "/pathway_enrichment_results.tsv"),
                sep="\t", quote = F, col.names = T, row.names = F)

    print("------------------------------------")
    print(fname)
    print("Number of genes in query:")
    print(length(DE_genes$Ensembl_ID))
    print("Number of pathways found:")
    print(summary(as.factor(pathway_gostres_table$source)))
    print("------------------------------------")

    if (nrow(pathway_gostres) > 0){ #if there are enriched pathways

        # Splitting results according to pathway resources (KEGG / REACTOME / GO)
        res <- split(pathway_gostres, pathway_gostres$source)
        for (df in res){

            db_source <- df$source[1]
            df$short_name <- sapply(df$term_name, substr, start=1, stop=50)

            # Plotting results for df
            df_subset <- data.frame(Pathway_name = df$short_name, Pathway_code = df$term_id, DE_genes = df$intersection_size, Pathway_size = df$term_size, Fraction_DE = (df$intersection_size / df$term_size), Padj = df$p_value, DE_genes_names = df$intersection)
            write.table(df_subset,
                        file = paste0("pathway_analysis", "/", fname, "/", make.names(db_source), "_pathway_enrichment_results.tsv"),
                        sep="\t", quote = F, col.names = T, row.names = F)

            # Enriched pathways horizontal barplots of padj values
            p <- ggplot(df_subset, aes(x=reorder(Pathway_name, Fraction_DE), y=Fraction_DE)) +
                geom_bar(aes(fill=Padj), stat="identity", width = 0.7) +
                geom_text(aes(label=paste0(df_subset$DE_genes, "/", df_subset$Pathway_size)), vjust=0.4, hjust=-0.5, size=3) +
                coord_flip() +
                scale_y_continuous(limits = c(0.00, 1.00), expand=expansion(mult=c(0,0.2))) +
                scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
                ggtitle("Enriched pathways") +
                xlab("") + ylab("Gene fraction (DE genes / Pathway size)")

            # If the plots are huge ggsave will throw an error even if limitsize=T, so I'm leaving limitsize=F and instead using trycatch
            tryCatch(
                {
                    ggsave(p, filename = paste0("pathway_analysis", "/", fname, "/enrichment_plots/", make.names(db_source), "_pathway_enrichment_plot.pdf"), device = "pdf", height = 5+0.5*nrow(df_subset), units = "cm", limitsize=F)
                },
                error=function(e) {
                    print(paste0("Could not save pathway_analysis", "/", fname, "/enrichment_plots/", make.names(db_source), "_pathway_enrichment_plot.pdf because of the following error:\n", e))
                }
            )
            tryCatch(
                {
                    ggsave(p, filename = paste0("pathway_analysis", "/", fname, "/enrichment_plots/", make.names(db_source), "_pathway_enrichment_plot.png"), device = "png", height = 5+0.5*nrow(df_subset), units = "cm", limitsize=F)
                },
                error=function(e) {
                    print(paste0("Could not save pathway_analysis", "/", fname, "/enrichment_plots/", make.names(db_source), "_pathway_enrichment_plot.png because of the following error:\n", e))
                }
            )
            tryCatch(
                {
                    ggsave(p, filename = paste0("pathway_analysis", "/", fname, "/enrichment_plots/", make.names(db_source), "_pathway_enrichment_plot.svg"), device = "svg", height = 5+0.5*nrow(df_subset), units = "cm", limitsize=F)
                },
                error=function(e) {
                    print(paste0("Could not save pathway_analysis", "/", fname, "/enrichment_plots/", make.names(db_source), "_pathway_enrichment_plot.svg because of the following error:\n", e))
                }
            )

            # Plotting heatmaps and KEGG pathways for all pathways
            print("Plotting heatmaps...")
            if (nrow(df) <= 100 & nrow(df) > 0) {
                conditions <- grepl("Condition", colnames(metadata))
                metadata_save <- as.data.frame(metadata[,conditions])
                metadata_name <- metadata[,c("QBiC.Code", "Secondary.Name")]
                row.names(metadata_save) <- apply(metadata_name,1,paste, collapse = "_")

                for (i in c(1:nrow(df))){
                    pathway <- df[i,]
                    gene_list <- unlist(strsplit(pathway$intersection, ","))
                    mat <- norm_counts[which(norm_counts$Ensembl_ID %in% gene_list), ]

                    # Skip the heatmaps for CI tests because especially png() works only very unreliably for the heatmaps for some reason
                    if (!isProvided(params$citest) & nrow(mat)>1){
                        dir.create(paste("pathway_analysis", fname, "pathway_heatmaps", sep="/"))

                        # Save matrix as table so that the values are accessible if heatmap plotting does not work properly
                        write.table(mat, file=paste0("pathway_analysis", "/",fname, "/", "pathway_heatmaps", "/", "Heatmap_normalized_counts_", pathway$source, "_", make.names(pathway$term_id), ".tsv"), sep="\t", quote=F, row.names=F)

                        # Reformat matrix so that it can be used by pheatmap (throws error if String columns/IDs are in the table)
                        rownames(mat) <- mat$gene_name
                        mat$gene_name <- NULL
                        mat$Ensembl_ID <- NULL
                        mat <- data.matrix(mat)

                        # Because the image devices sometimes don't work here, surround them with a tryCatch so that the code continues even if a certain heatmap is not saved
                        tryCatch(
                            {
                                png(filename = paste0("pathway_analysis", "/",fname, "/", "pathway_heatmaps", "/", "Heatmap_normalized_counts_", pathway$source, "_", make.names(pathway$term_id), ".png"), width = ifelse(nrow(mat)<=20, 200, 125)+ncol(mat)*40, height = 50+nrow(mat)*50)
                                pheatmap(mat = mat, annotation_col = metadata_save, main = paste("Heatmap of normalized expression values (z-scores) for genes in pathway ", pathway$short_name, "(",pathway$source,")",sep=" "), scale = "row", cluster_cols = params$heatmaps_cluster_cols, cluster_rows = params$heatmaps_cluster_rows)
                                dev.off()
                            },
                            error=function(e) {
                                print(paste0("Could not save pathway_analysis", "/",fname, "/", "pathway_heatmaps", "/", "Heatmap_normalized_counts_", pathway$source, "_", make.names(pathway$term_id), ".png because of the following error:\n", e))
                            }
                        )
                        tryCatch(
                            {
                                pdf(paste0("pathway_analysis", "/", fname, "/", "pathway_heatmaps", "/", "Heatmap_normalized_counts_", pathway$source, "_", make.names(pathway$term_id), ".pdf"), width = ifelse(nrow(mat)<=20, 50, 10)+ncol(mat)*0.1, height = 5+nrow(mat)*0.005)
                                pheatmap(mat = mat, annotation_col = metadata_save, main = paste("Heatmap of normalized expression values (z-scores) for genes in pathway ", pathway$short_name, "(",pathway$source,")",sep=" "), scale = "row", cluster_cols = params$heatmaps_cluster_cols, cluster_rows = params$heatmaps_cluster_rows)
                                dev.off()
                            },
                            error=function(e) {
                                print(paste0("Could not save pathway_analysis", "/", fname, "/", "pathway_heatmaps", "/", "Heatmap_normalized_counts_", pathway$source, "_", make.names(pathway$term_id), ".pdf because of the following error:\n", e))
                            }
                        )
                        tryCatch(
                            {
                                svg(paste0("pathway_analysis", "/", fname, "/", "pathway_heatmaps", "/", "Heatmap_normalized_counts_", pathway$source, "_", make.names(pathway$term_id), ".svg"), width = ifelse(nrow(mat)<=20, 50, 10)+ncol(mat)*0.1, height = 5+nrow(mat)*0.005)
                                pheatmap(mat = mat, annotation_col = metadata_save, main = paste("Heatmap of normalized expression values (z-scores) for genes in pathway ", pathway$short_name, "(",pathway$source,")",sep=" "), scale = "row", cluster_cols = params$heatmaps_cluster_cols, cluster_rows = params$heatmaps_cluster_rows)
                                dev.off()
                            },
                            error=function(e) {
                                print(paste0("Could not save pathway_analysis", "/", fname, "/", "pathway_heatmaps", "/", "Heatmap_normalized_counts_", pathway$source, "_", make.names(pathway$term_id), ".svg because of the following error:\n", e))
                            }
                        )
                        graphics.off() # Close all still open devices from errors. Tried doing this in finally, but that doesn't work
                    }

                    # Plotting pathway view only for kegg pathways
                    if (pathway$source == "KEGG"){
                        pathway_kegg <- sapply(pathway$term_id, function(x) paste0(short_organism_name, unlist(strsplit(as.character(x), ":"))[2]))

                        # Try plotting pathways, ignore pathways graphs containing errors as pathview crashes if plotting them.
                        tryCatch({
                            print_string <- paste0("Plotting pathway: ", pathway_kegg)
                            gene.data = DE_genes
                            gene.data.subset = gene.data[gene.data$Ensembl_ID %in% gene_list, c("Ensembl_ID","log2FoldChange")]
                            entrez_ids = AnnotationDbi::mapIds(species_library_installed, keys=as.character(gene.data.subset$Ensembl_ID), column = "ENTREZID", keytype=params$keytype, multiVals="first")
                            gene.data.subset <- gene.data.subset[!(is.na(entrez_ids)),]

                            if (length(entrez_ids)!=length(unique(entrez_ids))) {
                                print_string <- paste0("Skipping pathway: ", pathway_kegg,". This pathway has multiple IDs with same name.")
                            } else {
                                row.names(gene.data.subset) <- entrez_ids[!is.na(entrez_ids)]
                                gene.data.subset$Ensembl_ID <- NULL
                                pathview(gene.data  = gene.data.subset,
                                        pathway.id = pathway_kegg,
                                        species    = short_organism_name,
                                        out.suffix=paste(fname,sep="_"))
                                mv_command <- paste0("mv *.png *.xml ","./","pathway_analysis", "/",fname, "/", "KEGG_pathways", "/")
                                rm_command <- paste0("rm ","./","pathway_analysis", "/",fname, "/", "KEGG_pathways", "/", "*.xml")
                                system(mv_command)
                            }
                        }, error = function(e) {
                            print_string <- paste0("Skipping pathway: ",pathway_kegg,". This pathway file has errors in KEGG database.")
                        }, finally = {
                            print(print_string)
                        })
                    }
                }
            }
        }
    }
}

# Plotting heatmap for provided gene list
if (isProvided(params$path_genelist)){

    genelist_path = params$path_genelist
    genelist_heatmaps_dir <- "differential_gene_expression/plots/heatmap_gene_list"
    dir.create(genelist_heatmaps_dir)

    print("Plotting heatmaps...")
    conditions <- grepl("Condition", colnames(metadata))
    condition <- metadata[,conditions]
    metadata_save <- as.data.frame(condition)
    metadata_name <- metadata[,c("QBiC.Code", "Secondary.Name")]
    row.names(metadata_save) <- apply(metadata_name,1,paste, collapse = "_")

    gene_list_tab <- read.table(file=genelist_path, sep = "\t", header = F, quote="")
    gene_list_unique_tab <- data.frame(gene_list=unique(gene_list_tab$V1))

    norm_counts$gene_name <- toupper(norm_counts$gene_name)
    IDs <- norm_counts[,c("Ensembl_ID","gene_name")]

    genestoEnsmbl <- merge(x=gene_list_unique_tab, y=IDs, by.x="gene_list", by.y="gene_name", all.x=T)
    gene_list <- genestoEnsmbl$Ensembl_ID

    # Omit genes not present in the count table (NAs)
    gene_list <- na.omit(gene_list)

    rownames(norm_counts) <- norm_counts$Ensembl_ID
    mat <- norm_counts[which(norm_counts$Ensembl_ID %in% gene_list), ]

    if (nrow(mat)>1){

        # Reformat matrix so that it can be used by pheatmap (throws error if String columns/IDs are in the table)
        rownames(mat) <- mat$gene_name
        mat$gene_name <- NULL
        mat$Ensembl_ID <- NULL
        mat <- data.matrix(mat)

        # Save matrix as table so that the values are accessible if heatmap plotting does not work properly
        write.table(mat, file=paste0(genelist_heatmaps_dir, "/", "Heatmap_normalized_counts_gene_list.tsv"), sep="\t", quote=F, row.names=F)

        png(filename = paste0(genelist_heatmaps_dir, "/", "Heatmap_normalized_counts_gene_list.png"), width = 100+ncol(mat)*50, height = 50+nrow(mat)*100)
        pheatmap(mat = mat, annotation_col = metadata_save, main = "Genelist-specific Heatmap of normalized expression values (z-scores) for genes", scale = "row", cluster_cols = params$heatmaps_cluster_cols, cluster_rows = params$heatmaps_cluster_rows)
        dev.off()
        pdf(paste0(genelist_heatmaps_dir, "/", "Heatmap_normalized_counts_gene_list.pdf"), width = 10+ncol(mat)*0.05, height = 5+nrow(mat)*0.005)
        pheatmap(mat = mat, annotation_col = metadata_save, main = "Genelist-specific Heatmap of normalized expression values (z-scores) for genes", scale = "row", cluster_cols = params$heatmaps_cluster_cols, cluster_rows = params$heatmaps_cluster_rows)
        dev.off()
        svg(paste0(genelist_heatmaps_dir, "/", "Heatmap_normalized_counts_gene_list.svg"), width = 10+ncol(mat)*0.1, height = 5+nrow(mat)*0.005)
        pheatmap(mat = mat, annotation_col = metadata_save, main = "Genelist-specific Heatmap of normalized expression values (z-scores) for genes", scale = "row", cluster_cols = params$heatmaps_cluster_cols, cluster_rows = params$heatmaps_cluster_rows)
        dev.off()
    }
}
```

```{r pathway_analysis, echo=FALSE, results='asis', eval=params$pathway_analysis}

if (isProvided(params$set_background)) {
    background_list_text <- "The background gene list used for pathway analysis is saved [here](./pathway_analysis/metadata/custom_background.txt)"
} else {
    background_list_text <- ""
}

if (mv_status) {
    if (isProvided(params$custom_gmt)) {
        gost_text <- "A custom GMT file was provided for the gost query; it is saved [here](./pathway_analysis/metadata). In case this GMT file contained entries from datasources other than the selected ones, it was filtered and the resulting filtered GMT was used for querying. The filtered version is also saved to the metadata folder."
    } else {
        gost_text <- "A GMT file corresponding to the current gprofiler database version was downloaded to allow for reproducing the gost query; it is saved [here](./pathway_analysis/metadata). Note that the downloaded GMT contains entries from various datasources, not just the selected ones. Also, some datasources might be missing from the files due to licensing reasons."
    }
} else {
    gost_text <- paste0("The GMT file of the current gprofiler database could not be downloaded with this URL: ", gmt_url, ". For reproducibility reasons, try to download the GMT file manually by visiting https://biit.cs.ut.ee/gprofiler/gost, then selecting the correct organism and finally, in datasources, clicking 'combined ENSG.gmt'.")
}

# The following details block creates a collapsible explaining the output folders/files
cat(paste0("***

# Pathway analysis
The pathway analysis was performed with the `gProfiler2` tool.

After unzipping the results ZIP file, the pathway analysis results are stored in this folder: [pathway_analysis/](./pathway_analysis), and explained in this section.
Inside the pathway analysis results folder, a subfolder for each contrast used for the differential gene expression analysis is found. Inside each contrast folder, there is the following output:
<br><br><details>
<summary>Expand/collapse</summary>
- `*_gost_pathway_venn_diagram.pdf/png`
    - Venn diagrams showing the numbers of enriched pathways when using a background gene list vs when not using a bg list.
- `enrichment_plots/*_pathway_enrichment_plot.{pdf/png/svg}`
    - Barplots showing the proportion of differentially expressed genes in the pathway for a certain pathway database (might be missing if too many pathways were enriched for fitting into a plot).
- `gost_pathway_gostplot.{pdf/png/svg}`
    - Manhattan plots displaying all enriched pathways.
- `KEGG_pathways/`
    - Contains the KEGG pathways graphs with the log fold change of the differentially expressed genes.
- `pathway_heatmaps`
    - Contains heatmaps of the normalized gene counts for each of the differentially expressed pathways.
</details><br>",
gost_text,

"\n
## Enriched pathways {.tabset .tabset-pills}
The plot below summarizes the pathways that were found significantly enriched in DE genes for each contrast (padj value <= ", pathway_pval_text, ").
Only contrasts for which an enriched pathway was found are shown.
Hover over the dots to reveal the pathway names. The table below provides more detail on all enriched pathways."))
```

```{r gost, eval=params$pathway_analysis, out.height = "100%", out.width = "60%", warning=FALSE, message=FALSE, results='asis'}
contrast_files <- list.files(path=paste0("differential_gene_expression/DE_genes_tables/"))
q_list <- list()
q_names <- c()
contrast_list <- c()

#Use non-allgenes files for PA to only show DE genes
for (file in contrast_files){

    #Reading DE genes list
    fname <- tools::file_path_sans_ext(basename(file))
    DE_genes <- read.csv(file = paste0("differential_gene_expression/DE_genes_tables/", file), sep="\t", header = T)

    if(nrow(DE_genes) <= 1){
        next
    }
    q = as.character(DE_genes$Ensembl_ID)
    q_list <- append(q_list, list(q))
    q_names <- append(q_names, fname)
    contrast_list <- c(contrast_list, sapply(strsplit(fname, '_'), function(x) paste(x[5:contrast_len], collapse=' ')))
}
names(q_list) <- q_names

for (i in 1:length(q_names))  {

    if (length(q_list) > 0) {

        #gost query

        if (isProvided(params$set_background)) {
            gostres <- gost(query=q_list[[i]],
                        organism=gost_id,
                        significant=T,
                        correction_method="fdr",
                        sources=datasources,
                        user_threshold=params$pathway_adj_pval_threshold,
                        custom_bg=custom_background,
                        domain_scope="custom_annotated"
            )
        } else {
            gostres <- gost(query=q_list[[i]],
                        organism=gost_id,
                        significant=T,
                        correction_method="fdr",
                        sources=datasources,
                        user_threshold=params$pathway_adj_pval_threshold,
                        domain_scope="annotated"
            )
        }

        path_enrich <- as.data.frame(gostres$result)

        # Determine which max has to be set for the gostplot y axis: highest -log10(pval) (use min function as the smallest
        # p value produces the highest -log10) OR 17, as the gostplot caps at 16 (values>16 are set to 17)
        y_max <- min(ceiling(-log10(min(path_enrich$p_value, na.rm=T))) + 3, 18)

        if (nrow(path_enrich) > 0){
            cat('### Contrast: ', contrast_list[i], '\n')
            cat("\n\n")

            pg2 <- gostplot(gostres, capped=T, interactive=T) %>% 
            layout(title = q_names[i],
                    yaxis = list(range = list(-1, y_max)))
            pg2[['x']][['layout']][['annotations']][[1]][['x']] <- -params$pathway_adj_pval_threshold
            pg2[['x']][['layout']][['annotations']][[2]][['text']] <- ''
            print(htmltools::tagList(pg2))
            cat("\n\n")
            

            df_subset <- data.frame(Contrast = q_names[i], Pathway_name = path_enrich$term_name, Pathway_code = path_enrich$term_id,
            DE_genes = path_enrich$intersection_size, Pathway_size = path_enrich$term_size,
            Fraction_DE = formatC(path_enrich$intersection_size / path_enrich$term_size, digits=3),
            Padj = formatC(path_enrich$p_value, digits=3))
            colnames <- c("Contrast", "Pathway name", "Pathway code", "DE genes in pathway (N)", "Total genes in pathway (N)",
            "Fraction of DE genes in pathway", "Padj value (pathway enrichment)")
            path_enrich_table <- DT::datatable(df_subset, options = list(scrollX  = "100%", scrollY = "400px", pageLength = -1, dom = 'ft'))
            print( htmltools::tagList(path_enrich_table) )
            cat("\n\n")
            cat("\n")
            
            
        } else {
                cat('### Contrast: ', contrast_list[i], '\n')
                cat("\n\n")
                cat(paste("No enriched pathways were found in the selected pathway databases."))
                path_enrich=data.frame(list())
                cat("\n\n")
        }
    } else {
        cat("No DE genes were found, pathway analysis not possible.")
        path_enrich=data.frame(list())
    }

}
```


```{r conditional_KEGG_contrasts, echo=FALSE, results='asis', eval=params$pathway_analysis}
cat(paste0("## KEGG pathway maps
For KEGG pathways, a KEGG pathway map was also generated that can be found in the subfolder named `KEGG_pathways`, for each contrast folder.
\
"))
```

```{r conditional_pathway_maps, echo=FALSE, results='asis', eval=params$pathway_analysis}
cat(paste0("## Pathway heatmaps
For all considered contrasts, a heatmap of all DE genes that were found in each of the pathways is produced.
You can find these heatmaps inside the [pathway_analysis](./pathway_analysis) folder, inside the subfolder corresponding to each of the contrasts,
and the subfolder: `pathway_heatmaps`.
\
"))
```
<!-- PA end -->

# Summary and outlook

```{r quote, echo=FALSE, results='asis'}

# Only add hyperlink to quote file if it was provided in the params
quote_string <- ifelse(
    isProvided(params$path_quote),
    paste0("The results for all work packages, as described in the [quote/offer](", params$path_quote, "), can be found in this report."),
    paste0("The results for all work packages (no quote/offer given to describe them) can be found in this report.")
)
cat(quote_string)

# Initiate vars in case no software_versions were provided
software_versions_csv <- F
quant_tool <- params$input_type
```

Further support for this project will be restricted to the results presented in this report.
For further analysis (e.g. the re-analysis of the dataset) we will generate a new quote containing cost estimates.

```{r software_versions, bootstrap.show.message=FALSE, echo=FALSE, message=FALSE, eval=isProvided(params$path_software_versions)}
# Import the .csv or .yml file output by the rna-seq Nextflow pipeline
software_versions_csv <- endsWith(params$path_software_versions, ".csv") || endsWith(params$path_software_versions, ".tsv")
if (software_versions_csv) {
    version_csv <- read.csv(file = params$path_software_versions, sep="\t", header = FALSE)
    version <- setNames(as.list(version_csv$V2), version_csv$V1)
} else {
    version <- read_yaml(params$path_software_versions)
}

if (software_versions_csv) {
    if (params$input_type == "featurecounts") {
        quant_tool <- "featureCounts"
        quant_version <- as.character(version["featureCounts"])
        quant_cite <- "[@liao2014featurecounts]"
    }
} else {
    if (params$input_type == "rsem") {
        quant_tool <- "RSEM"
        quant_version <- as.character(version["RSEM_CALCULATEEXPRESSION"][[1]]["rsem"])
        quant_cite <- "[@li2011rsem]"
    } else if (params$input_type == "salmon") {
        quant_tool <- "Salmon"
        quant_version <- as.character(version["SALMON_QUANT"][[1]]["salmon"])
        quant_cite <- "[@patro2017salmon]"
    } else if (params$input_type == "smrnaseq") {
        quant_tool <- "SAMtools"
        quant_version <- as.character(version["SAMTOOLS_IDXSTATS"][[1]]["samtools"])
        quant_cite <- "[@li2009sequence; @li2011statistical]"
    }
}
```

<!-- TODO all software_versions right (+gprofiler2, reference genome) and nicer description of computational methods -->

# Computational methods

```{r no_software_versions, echo=FALSE, results='asis', eval=!isProvided(params$path_software_versions)}
cat("No software versions file was provided for primary analysis.")
```

```{r software_versions_RNASeq, echo=FALSE, results='asis', eval=isProvided(params$path_software_versions)}

# In the following part, I use newlines (in code) where possible whenever the paste0 function switches from a string to a variable call to better distinguish between the two so it is clearer in which lines quotes are needed and in which not --> Cannot always use newlines as this sometimes translates into the report.html

if (params$input_type == "featurecounts"){
cat(paste0(
"## RNAseq data analysis

The Nextflow-based nf-core pipeline `rnaseq ", as.character(ifelse(software_versions_csv, version["nf-core/rnaseq"], version["Workflow"][[1]]["nf-core/rnaseq"])),
"` [^1] was used for the RNAseq Bioinfomatics analysis. `FASTQC ",
as.character(ifelse(software_versions_csv, version["FastQC"], version["FASTQC"][[1]]["fastqc"])),
"` [^3] [@andrews2010fastqc] was used to determine quality of the FASTQ files.
Subsequently, adapter trimming was conducted with `Trim Galore ",
as.character(ifelse(software_versions_csv, version["Trim Galore!"], version["TRIMGALORE"][[1]]["trimgalore"])),
"` [^4] [@krueger2012trim]. `STAR v",
as.character(ifelse(software_versions_csv, substring((version["STAR"]), 7, ), version["MAKE_TRANSCRIPTS_FASTA"][[1]]["star"])),
"` [@Dobin2013] aligner was used to map the reads that passed the quality control to the reference genome.
The RNA-seq data quality control was performed with `RSeQC ",
as.character(ifelse(software_versions_csv, version["RSeQC"], version["RSEQC_BAMSTAT"][[1]]["rseqc"])),
"` [@wang2012rseqc] and read quantification of the features (e.g. genes) with `",
quant_tool,
" ",
quant_version,
"` ",
quant_cite,
"."
))
} else if (params$input_type == "smrnaseq"){
cat(paste0(
"## smRNA-seq data analysis

The Nextflow-based nf-core pipeline `smrnaseq ", as.character(version["Workflow"][[1]]["nf-core/smrnaseq"]),
"` [^6] was used for the smRNA-seq Bioinfomatics analysis. `FASTQC ",
as.character(version["FASTQC"][[1]]["fastqc"]),
"` [^3] [@andrews2010fastqc] was used to determine the quality of the miRNA samples. ",
ifelse("TRIMGALORE" %in% names(version), paste0("Subsequently, adapter trimming was conducted with `Trim Galore ",
as.character(version["TRIMGALORE"][[1]]["trimgalore"]),
"` [^4] [@krueger2012trim]."),
    ifelse("FASTP" %in% names(version), paste0("Subsequently, adapter trimming was conducted with `fastP ",
    as.character(version["FASTP"][[1]]["fastp"]),
    "` [^7] [@chen2018fastp; @chen2023ultrafast]."),
        "")),
" `Bowtie v", as.character(version["BOWTIE_MAP_HAIRPIN"][[1]]["bowtie"]), "` [@langmead2009ultrafast] aligner was used to map the reads that passed the quality control to the reference database.
The smRNA-seq data quality control was performed with `miRTrace ",
as.character(version["MIRTRACE_RUN"][[1]]["mirtrace"]),
"` [^8] [@kang2018mirtrace] and read quantification of the features (e.g. genes) with `",
quant_tool,
" ",
quant_version,
"` ",
quant_cite,
".",
"\nThe output from `SAMtools`, more specifically the  `<QBiC-Code>_mature_hairpin.sorted.idxstats` and `<QBiC-Code>_mature.sorted.idxstats` files, were then used to create a counts matrix. This was done by combining all of these files into a single table, using only the rownames and the third column (second column after the rownames) of each file which contains the counts. The last row of each file (which always has an asterisk `*` as rowname) was excluded. The resulting counts matrix was used as input for the `rnadeseq` pipeline."
))
}
```

```{r MQC_cite, echo=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/"))&software_versions_csv&isProvided(params$path_software_versions)}
cat(paste0("\nAn aggregation of the quality control for the RNAseq analysis was performed with `MultiQC ", as.character(version["MultiQC"]), "` [^2] [@ewels2016multiqc]."))
```

```{r software_versions_DE, echo=FALSE, results='asis'}
cat(paste0(
"## Differential gene expression analysis

The differential expression analysis was performed by the use of the `rnadeseq ",
as.character(params$revision),
"` pipeline [^5], which was written using the nf-core template [@ewels2020nf]. For differential expression analysis, the read quantification data resulting from `",
quant_tool, "` were processed with the R package `DESeq2 v",
packageVersion("DESeq2"),
"` [@love2014differential]. The thresholds for differentially expressed genes were set to ",
pval_text, " for the adjusted p-value and ",
logFC_text, " for the log2 Fold Change."
))

```{r conditional_pathway, echo=FALSE, results='asis', eval=isProvided(params$pathway_analysis)}
version_gprofiler2 = packageVersion("gprofiler2")
version_annotation = packageVersion("AnnotationDbi")
name_species       = params$species_library
version_species    = packageVersion(name_species)

if (isProvided(params$custom_gmt)){
    database_string <- paste0("Also, a gprofiler query with this custom GMT file was done: `", basename(params$custom_gmt), "`.")

    if (isProvided(params$datasources)) {
        database_string <- paste(database_string, "Entries of the following datasources were considered: ")
        dbs <- paste(datasources, collapse="`, `")
        database_string <- paste0(database_string, "`", dbs, "`.")
    } else {
        database_string <- ""
    }

} else if (isProvided(params$datasources)) {
    database_string = "Also, the following databases were queried: "
    database_version_info <- get_version_info(params$organism)
    database_string <- paste0(database_string, "`gprofiler: ", database_version_info$gprofiler_version, "`")
    for (db in datasources) {
        database_string <- paste0(database_string, ", `", db, ": ", database_version_info$sources[[db]]$version, "`")
    }
} else {
    database_string <- paste("All datasources available in g:Profiler were considered (check https://biit.cs.ut.ee/gprofiler/gost and https://biit.cs.ut.ee/gprofiler/page/docs for more info).")
}

cat(paste0(
"\n## Pathway enrichment analysis

For pathway analysis, the R packages `gprofiler2 v", version_gprofiler2,
" `, `AnnotationDbi v", version_annotation,
"` and `", name_species, " v", version_annotation,
"` were used. ", database_string, ".\n",
"Pathways were classified as enriched for those genes with an adjusted p-value <= ", pathway_pval_text, "."
))
```

Graphs were produced in RStudio with ``r R.version.string`` mainly using the R package `ggplot2 v`r packageVersion("ggplot2")`` . Final reports were produced using the R package `rmarkdown v`r packageVersion("rmarkdown") ``, with the `knitr v`r packageVersion("knitr")`` and `DT v`r packageVersion("DT")`` R packages.

## Package version overview

The following lists all packages used for analysis, together with their versions.

```{r versions}
sessioninfo::session_info()%>%
    details::details(summary = 'Session info/used packages')
```

---

---

# Bibliography

[^1]: https://github.com/nf-core/rnaseq
[^2]: http://multiqc.info/
[^3]: https://www.bioinformatics.babraham.ac.uk/projects/fastqc/
[^4]: https://www.bioinformatics.babraham.ac.uk/projects/trim_galore/
[^5]: https://github.com/qbic-pipelines/rnadeseq

[^6]: https://github.com/nf-core/smrnaseq
[^7]: https://github.com/OpenGene/fastp
[^8]: https://github.com/friedlanderlab/mirtrace
