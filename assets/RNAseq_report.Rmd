---
output:
    html_document:
        toc: true # table of contents
        toc_float: true # float the table of contents to the left of the main document content
        toc_depth: 3 # header levels 1,2,3
        theme: default
        number_sections: true # add section numbering to headers
        df_print: paged # tables are printed as an html table with support for pagination over rows and columns
        css: ./corp-styles.css
        highlight: pygments
        pdf_document: true
bibliography: ./references.bibtex
params:

    #Main input args
    input_type: ''
    path_gene_counts: ''
    path_metadata: ''
    path_design: ''
    path_gtf: '' # only for star_rsem and star_salmon input

    #DESeq2 args
    path_contrast_matrix: ''
    path_contrast_list: ''
    path_contrast_pairs: ''
    path_genelist: ''
    path_relevel: ''
    batch_effect: ''
    logFC_threshold: ''
    adj_pval_threshold: ''
    trafo: ''
    nsub_genes: ''
    round_DE: ''

    #Pathway analysis args
    pathway_analysis: ''
    organism: ''
    species_library: ''
    keytype: ''
    min_DEG_pathway: ''
    custom_gmt: ''
    set_background: ''
    custom_background: ''

    #Additional args for the report
    path_proj_summary: ''
    path_quote: ''
    path_software_versions: ''
    revision: ''

    #Additional arg to indicate that a github test is run
    citest: ''

# Author: Silvia Morini, Gisela Gabernet, Simon Heumos
---

```{r init, include=F}
# set a seed in case some background calculations are random-based
set.seed(10)

# svg path for the little svg format icon displayed in the interactive plots for svg export; based on https://www.svgviewer.dev/:
svg_icon_path <- 'M228 319.5H12C5.64873 319.5 0.5 314.351 0.5 308V12C0.5 5.64873 5.64873 0.5 12 0.5H159.175C159.571 0.5 159.952 0.656748 160.233 0.936021L239.057 79.2681C239.341 79.5497 239.5 79.9326 239.5 80.3321V308C239.5 314.351 234.351 319.5 228 319.5Z'
svg_icon_fill <- 'darkgrey'
svg_icon_transform <- 'scale(0.07)'
svg_icon_viewbox <- '0 0 240 320'

# This adds a save-to-svg button to the plot menubar
svg_exp <- list(
    name = "Download plot as an svg",
    icon = list(
        path = svg_icon_path,
        fill = svg_icon_fill,
        transform = svg_icon_transform,
        viewbox = svg_icon_viewbox
    ),
    click = htmlwidgets::JS(
        "function(pg) {
            Plotly.downloadImage(pg, {format: 'svg', filename: 'newplot'});
        }"
    )
)

# Function for setting heatmap row/column label size depending on number of rows/columns
label_size <- function(dimension_int) {
    val <- max(c(2, 10-dimension_int/15))
    return(val)
}
```

```{r param_validation, echo=FALSE, message=FALSE, warning=FALSE, results = 'hide'}
#self-written isProvided function that tests for zero-length, emptystring and NULL (for some reason, some params cannot be tested with emptystring)
isProvided <- function(value) {
    result <- TRUE
    tryCatch(
    {
        if (length(value)<1) {
            result <- FALSE
        }
        else {
            tryCatch(
        {
            if (value %in% c("", "null", "NULL", "false", "FALSE")) {
                result <- FALSE
            }
        },
        error=function(cond) {
            tryCatch(
                {
                    if (is.null(value)) {
                        result <- FALSE
                    }
                },
                error=function(cond) {
                    message("isProvided got the following error:")
                    message(cond)
                    message(paste("Object type:", typeof(value)))
                    message(paste("Object:", value))
                    quit(1)
                }
            )
        }
    )
        }
    },
    error=function(cond) {
        message("isProvided got the following error:")
                    message(cond)
                    message(paste("Object type:", typeof(value)))
                    message(paste("Object:", value))
                    quit(1)
    }
    )
    return(result)
}

#this function is used to produce a more informative error message when count table and metadata table disagree
write_error_msg <- function(counts, qbicCodes) {
    error_msg <- "Count table headers do not exactly match the metadata table sample names!\n"
    
    counts_msg <- ""
    counts_offending <- ""
    for (c in names(counts)) {
        if (!(c %in% qbicCodes)) {
            counts_msg <- "Offending value(s) in count table:\n"
            counts_offending <- paste0(counts_offending, c, "\n")
        }
    }
    
    meta_msg <- ""
    meta_offending <- ""
    for (m in qbicCodes) {
        if (!(m %in% names(counts))) {
            meta_msg <- "Offending value(s) in metadata table:\n"
            meta_offending <- paste0(meta_offending, m, "\n")
        }
    }
    return(paste0(error_msg, counts_msg, counts_offending, meta_msg, meta_offending))
}

#Check necessary params
if (!(params$input_type %in% c("featurecounts", "rsem", "salmon"))){
    stop(paste0("Wrong input type ", params$input_type, ", must be one of [featurecounts, rsem, salmon]!"))
}
if (params$input_type %in% c("rsem", "salmon") & !isProvided(params$path_gtf)){
    stop(paste0("For input type salmon, gtf file needs to be provided!\nIf using igenomes, please check that the entry for your genome contains a gtf file and otherwise provide one with `--gtf`."))
}
if (!isProvided(params$path_gene_counts)){
    print_help(opt_parser)
    stop("Counts table needs to be provided!")
}
if (!isProvided(params$path_metadata)){
    print_help(opt_parser)
    stop("Metadata table needs to be provided!")
}
if (!isProvided(params$path_design)){
    print_help(opt_parser)
    stop("Linear model design file needs to be provided!")
}

# Check if more than one contrast option was provided
contrast_vector <- c(isProvided(params$path_contrast_list), isProvided(params$path_contrast_matrix), isProvided(params$path_contrast_pairs))
if (length(contrast_vector[contrast_vector==TRUE]) > 1) {
    stop("Provide only one of contrasts_matrix / contrasts_list / contrasts pairs!")
}
```

```{r load_DE_libs, echo=FALSE, message=FALSE, warning=FALSE, results = 'hide'}
# Load all necessary libs invisibly
invisible( lapply(c(
"RColorBrewer",
"reshape2",
"genefilter",
"DESeq2",
"ggplot2",
"ggrepel",
"dplyr",
"plyr",
"vsn",
"gplots",
"optparse",
"svglite",
"extrafont",
"limma",
"tximeta",
"tximport",
"SummarizedExperiment",
"impute",
"kableExtra",
"knitr",
"formattable",
"plotly",
"webshot",
"htmlwidgets",
"pheatmap",
"DT",
"sessioninfo",
"details",
"heatmaply",
"tools",
"yaml"
), library, character.only=T))

# Import python sys so that the save_image command works
reticulate::py_run_string("import sys")
```

```{r create_outdirs, echo=FALSE, message=FALSE, warning=FALSE, results = 'hide'}

# create directories needed
ifelse(!dir.exists("differential_gene_expression"), dir.create("differential_gene_expression"), FALSE)
dir.create("differential_gene_expression/metadata")
dir.create("differential_gene_expression/plots")
dir.create("differential_gene_expression/plots/boxplots_example_genes")
dir.create("differential_gene_expression/plots/boxplots_requested_genes")
dir.create("differential_gene_expression/plots/further_diagnostics_plots")
dir.create("differential_gene_expression/gene_counts_tables")
dir.create("differential_gene_expression/DE_genes_tables")
dir.create("differential_gene_expression/allgenes")
dir.create("differential_gene_expression/final_gene_table")
```

```{r project_data, bootstrap.show.message=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
df <- read.csv(file = params$path_proj_summary, sep="\t", header = TRUE)

# Import the .tsv file downloadable from https://portal.qbic.uni-tuebingen.de/portal/web/qbic/user-database -> Projects
projectcode = as.character(df$Sub.Project)

# Set the title; if the title is too long, it would get covered by the logo, so it is split in 2 or 3 parts.
title = as.character(df$Short.Title)

## function to split the title
splitInParts <- function(string, size){
        pat <- paste0('(?<=.{',size,'})')
        strsplit(string, pat, perl=TRUE)
    }
title_split=splitInParts(title, 65)
PI = as.character(df$Principal.Investigator)
PI_address = as.character(df$PI.Address)
PI_email = as.character(df$PI.E.Mail)
PI_institute = as.character(df$PI.Institute)
PI_organization = as.character(df$PI.Organization)
PM = as.character(df$Project.Manager)
PM_email = as.character(df$Manager.E.Mail)
description = as.character(df$Description)
```

---
title: "`r projectcode` - Project Report"
subtitle: "`r sapply(title_split, paste, collapse=" <br> ")`"
author: "`r PM`, Bioinformatics Research Scientist"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
---

<img src="./logo.png" style="position:absolute;top:0px;right:0px;" height="200" width="200" />
<div class="watermark">QBiC</div>

```{r docSetup, bootstrap.show.code = FALSE, dev = c('png'), bootstrap.show.message=FALSE, echo=FALSE, message=FALSE, warning=FALSE}

## knitrBoostrap and device chunk options
options(warn = -1)                          # suppress warnings and messages
opts_chunk$set(bootstrap.show.code = FALSE, dev = 'png', echo=FALSE)
```

\
\
\
\
**Project Members:**

**_`r PI`_**

`r PI_email`

`r PI_institute`

`r PI_organization`

`r PI_address`

\
\
**QBiC contacts:**

**_`r PM`_**

`r PM_email`

Auf der Morgenstelle 10, 72076 Tuebingen

---

---

# Introduction and aims

`r description`

# Sample metadata

<!-- metadata start -->

```{r read_metadata, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
# Load metadata: sample preparations tsv file from qPortal
metadata <- read.table(params$path_metadata, sep="\t", header=TRUE,na.strings =c("","NaN"), quote=NULL, stringsAsFactors=F, dec=".", fill=TRUE, row.names=1)
if (params$pathway_analysis) {

    #create copy of metadata for pathway_analysis
    metadata_PA <- read.table(file=params$path_metadata, sep = "\t", header = T, quote="")
}
system(paste("mv ",params$path_metadata," differential_gene_expression/metadata/metadata.tsv",sep=""))
qbicCodes <- rownames(metadata)

# Make sure metadata is factor where needed
names(metadata) = gsub("Condition..","condition_",names(metadata))
conditions = names(metadata)[grepl("condition_",names(metadata))]
for (i in conditions) {
    metadata[,i] = as.factor(metadata[,i])
}
# process secondary names and change row names in metadata
metadata$Secondary.Name <- gsub(" ; ", "_", metadata$Secondary.Name)
metadata$Secondary.Name <- gsub(" ", "_", metadata$Secondary.Name)
metadata$sampleName = paste(row.names(metadata),metadata$Secondary.Name,sep="_")
row.names(metadata) = metadata$sampleName
metadata_save <- metadata

# Load count table for FeatureCounts
if (params$input_type == "featurecounts"){
    count.table <- read.table(params$path_gene_counts,  header = T,sep = "\t",na.strings =c("","NA"),quote=NULL,stringsAsFactors=F,dec=".",fill=TRUE,row.names=1)
    count.table$Ensembl_ID <- row.names(count.table)
    drop <- c("Ensembl_ID","gene_name")
    gene_names <- count.table[,drop]

    # Reduce sample names to QBiC codes in count table
    names(count.table) <- substr(names(count.table), 1, 10)
    count.table <- count.table[ , !(names(count.table) %in% drop)]

    # Remove lines with "__" from HTSeq, not needed for featureCounts (will not harm here)
    count.table <- count.table[!grepl("^__",row.names(count.table)),]

    # Do some hard filtering for genes with 0 expression
    count.table = count.table[rowSums(count.table)>0,]

    # Need to order columns in count.table
    count.table <- count.table[, order(names(count.table))]

    if (!identical(names(count.table),qbicCodes)) {
    error_out <- write_error_msg(count.table, qbicCodes)
    stop(paste0(error_out, "\n"), call.=F)
    }
    names(count.table) = metadata$sampleName

    # Write raw counts to file
    count_table_names <- merge(x=gene_names, y=count.table, by.x = "Ensembl_ID", by.y="row.names")
    write.table(count_table_names, paste("differential_gene_expression/gene_counts_tables/raw_gene_counts.tsv",sep=""), append = FALSE, quote = FALSE, sep = "\t",eol = "\n", na = "NA", dec = ".", row.names = F, qmethod = c("escape", "double"))
}

# to get all possible pairwise comparisons, make a combined factor
conditions <- grepl(colnames(metadata),pattern = "condition_")
conditions_contrasts <- conditions # save copy that might be changed in contrast section and will be used for boxplots
metadata$combfactor <- apply(as.data.frame(metadata[ ,conditions]),1,paste, collapse = "_")

# Read design file
design <- read.csv(params$path_design, sep="\t", header = F)
write.table(design, file="differential_gene_expression/metadata/linear_model.txt", sep="\t", quote=F, col.names = F, row.names = F)

# condition: if there is a RIN column in Sample_preparations.tsv, prints a statement and the table with the RIN column;
# if there is no RIN column, or the column has one or more NAs, print only the metadata sheet.
QAfile = paste0(wd, "/differential_gene_expression/metadata/metadata.tsv")

no_RIN = FALSE
RIN=FALSE
if(file.exists(QAfile)){
    df_QA <- read.table(QAfile, header=TRUE, sep="\t", check.names = FALSE)
    conditions <- grepl(colnames(df_QA),pattern = "Condition")
    df_QA_cond <- as.data.frame(df_QA[ ,conditions])
    colnames(df_QA_cond) <- colnames(df_QA)[conditions]
    df_QA_neat <- df_QA[,c("QBiC Code", "Secondary Name")]

    #add "Sample Type" only if present in metadata.tsv
    if ("Sample Type" %in% colnames(df_QA)) {
            df_QA_neat[,c("Sample Type")] <- df_QA[,c("Sample Type")]
    }
    df_QA_neat <- merge(df_QA_neat, df_QA_cond, by="row.names")
    df_QA_neat$Row.names <- NULL
    if ("RIN" %in% colnames(df_QA)) {
        if (any(is.na(df_QA$RIN))) {
            no_RIN <- TRUE
        } else {
            RIN <- TRUE
            df_QA_neat$RIN <- df_QA$RIN
        }
    } else {
        no_RIN <- TRUE
    }
} else {
    no_RIN <- TRUE
}
```

```{r RIN_block, echo=FALSE, results='asis', eval=RIN}
cat("\
The samples description and grouping, including quality assessment of the RNA samples,
is summarized in the table below and can be found [here](./differential_gene_expression/metadata/metadata.tsv).
The RNA Integrity Number (RIN) value has a maximum value of 10.
\
")
kable(df_QA_neat) %>%
    kable_styling() %>%
    scroll_box(width = "100%", height = "400px")
```

```{r noRIN_block, echo=FALSE, results='asis', eval=no_RIN}
cat("\
The samples description and grouping is summarized in the table below and can be
found [here](./differential_gene_expression/metadata/metadata.tsv).
\
")
if ("RIN" %in% colnames(df_QA_neat)){df_QA_neat$RIN <- NULL}
DT::datatable(df_QA_neat, options = list(scrollX  = "100%", scrollY = "400px", pageLength = -1, dom = 'ft'))
```

<!-- DESeq2 start -->
<!-- This block needs to be executed before the rest of the code as the variables will be needed -->

```{r DESeq, echo=FALSE, message=FALSE, warning=FALSE, results = 'hide'}

################## RUN DESEQ2 ######################################
# Run DESeq function
if (params$input_type == "featurecounts") {
    cds <- DESeqDataSetFromMatrix( countData =count.table, colData =metadata, design = eval(parse(text=as.character(design[[1]]))))
    cds <- DESeq(cds,  parallel = FALSE)
} else if (params$input_type %in% c("rsem", "salmon")) {
    ## Create a dataframe which consists of both the gene id and the transcript name
    gtf <- rtracklayer::import(params$path_gtf)
    gtf <- as.data.frame(gtf, header=T)
    tx2gene_gtf <- gtf[c("transcript_id", "gene_id")]
    tx2gene_gtf <- distinct(tx2gene_gtf)

    # As the tximport parameter ignoreTxVersion=T does not reliably work (I think it only ignores the version
    # in the input files, not in the gtf), this removes decimals from the transcript_id values,
    # e.g. transcript_id "AT1G01010.1" --> transcript_id "AT1G01010"
    tx2gene_gtf[] <- lapply(tx2gene_gtf, function(x) gsub("\\.\\d+", "", x))
    colnames(tx2gene_gtf) <- c("transcript_id", "gene_id") #, "TXID"
    gene_names <- gtf[c("gene_id", "gene_name")]
    colnames(gene_names) <- c("Ensembl_ID", "gene_name")
    gene_names <- distinct(gene_names)
    rownames(gene_names) <- gene_names[,1]

## Load Rsem count files
    if (params$input_type == "rsem") {

        #rsem saves output into one file per sample in an output folder
        #-->the sample name is in the file name
        files <- file.path(gsub("/$", "", params$path_gene_counts), paste0(qbicCodes, ".genes.results"))
        if (!(all(file.exists(files)))) {
            missing_files <- "DESeq2.R could not find all of the specified <QBiC-code>.genes.results files! Please check that for all QBiC codes in the metadata sheet, a <QBiC-code>.genes.results file is present in the gene_counts folder and make sure that no typos exist. The following file(s) could not be found: "
            for (f in files) {
                if (!file.exists(f)) {
                    missing_files <- paste0(missing_files, f, ", ")
                }
            }
            missing_files <- paste0(substring(missing_files, 1, nchar(missing_files)-2), ".")
            stop(missing_files, call.=F)
        }

        #Extract condition columns and other info for tximeta
        condition_names <- unlist(strsplit(design[,1], split = " "))
        condition_names <- grep("condition|batch", condition_names, value=T)
        sampleconditions <- data.frame(metadata[,condition_names])
        colnames(sampleconditions) <- condition_names
        coldata <- data.frame(files = files, names= qbicCodes, sampleconditions)
        coldata$combfactor <- metadata$combfactor
        rownames(coldata) <- NULL

        #Do tximeta, this is necessary to run DESeq on rsem (imports the rsem output
        #and modifies them as they are not integers and can not directly be used for cds)
        se <- tximeta(coldata, type="rsem", txIn=FALSE, txOut=FALSE, skipMeta=TRUE)
        assays(se)$length[ assays(se)$length == 0] <- NA # set these as missing

        #Impute lengths for the 0-length values:
        length_imp <- impute.knn(assays(se)$length)
        assays(se)$length <- length_imp$data

        #dds from SummarizedExperiment <se>, then run DESeq
        cds <- DESeqDataSet(se, design = as.formula(eval(parse(text=as.character(design[[1]])))))
        cds <- DESeq(cds)

# Load salmon count files
    } else if (params$input_type == "salmon") {

        #salmon saves output to one file per sample, each file is contained in a subfolder of the output folder
        #-->the sample name is in the subfolder name, not in the file name!
        files <- file.path(gsub("/$", "", params$path_gene_counts), qbicCodes, "quant.sf")
        if (!(all(file.exists(files)))) {
            missing_files <- "DESeq2.R could not find all of the specified <QBiC-code>/quant.sf files! Please check that for all QBiC codes in the metadata sheet, a <QBiC-code>/quant.sf file is present in the gene_counts folder and <QBiC-code> subfolder and make sure that no typos exist. The following file(s) could not be found: "
            for (f in files) {
                if (!file.exists(f)) {
                    missing_files <- paste0(missing_files, f, ", ")
                }
            }
            missing_files <- paste0(substring(missing_files, 1, nchar(missing_files)-2), ".")
            stop(missing_files, call.=F)        }

        #The following steps are necessary for the processing of salmon output as the files do
        # not contain integer counts and can therefore not be directly used for cds
        ## Import all of the samples information and transform the identifiers
        txi.salmon <- tximport(files, type = "salmon", tx2gene = tx2gene_gtf, ignoreTxVersion = T)

        # Run cds with tximport depending on whether rsem or salmon was used
        #Extract condition columns and other info for tximeta
        condition_names <- unlist(strsplit(design[,1], split = " "))
        condition_names <- grep("condition|batch", condition_names, value=T)
        sampleconditions <- data.frame(metadata[,condition_names])
        colnames(sampleconditions) <- condition_names
        coldata <- data.frame(files = files, names= qbicCodes, sampleconditions)
        coldata$combfactor <- metadata$combfactor
        rownames(coldata) <- qbicCodes
        cds <- DESeqDataSetFromTximport(txi=txi.salmon, colData =coldata, design = eval(parse(text=as.character(design[[1]]))))
        cds <- DESeq(cds)
    }
} else {
    stop(paste0("Invalid input type: ", params$input_type, "! Input type must be one of: featurecounts, rsem, salmon!"))
}

#Apply relevel if provided to metadata
if (isProvided(params$path_relevel)) {
    relevel_table <- read.table(params$path_relevel, sep="\t", header = T, colClasses = "character")
    write.table(relevel_table, file="differential_gene_expression/metadata/relevel.tsv")
    for (i in c(1:nrow(relevel_table))) {
        relev <- relevel_table[i,]
        cds[[paste(relev[1])]] <- relevel(cds[[paste(relev[1])]], paste(relev[2]))
    }
}

# sizeFactors(cds) as indicator of library sequencing depth
if (params$input_type == "featurecounts") {
    sf <- sizeFactors(cds)
} else {
    # If tximport was used, sizeFactors doesn't work, so use workaround as described here: https://support.bioconductor.org/p/97676/
    nm <- assays(cds)[["avgTxLength"]]
    sf <- estimateSizeFactorsForMatrix(counts(cds)/nm)
}
write.table(sf,paste("differential_gene_expression/gene_counts_tables/sizeFactor_libraries.tsv",sep=""), append = FALSE, quote = FALSE, sep = "\t",eol = "\n", na = "NA", dec = ".", row.names = T,  col.names = F, qmethod = c("escape", "double"))

# Write cds assay table to file
write.table(counts(cds, normalized=T), paste0("differential_gene_expression/gene_counts_tables/deseq2_library_scaled_gene_counts.tsv"), append=F, quote = F, sep = "\t", eol = "\n", na = "NA", dec = ".", row.names = T, col.names = T, qmethod = c("escape", "double"))

# Or for rsem/salmon save folder/file names to txt file
if (params$input_type == "rsem") {
    write(files, file="differential_gene_expression/metadata/star_rsem_files.txt")
} else if (params$input_type == "salmon") {
    write(files, file="differential_gene_expression/metadata/star_salmon_files.txt")
}

############################## TRANSFORMED AND NORMALIZED COUNTS ###################
# Prepare variables and text snippets for report
vst_cutoff <- 0.05
var_sizeFactors <- var(sf)
run_rlog <- T
trafo_long_text <- "regularized logarithm (rlog)"
trafo_override_text <- ""
nsub_genes_text <- ""
if (params$trafo == "vst-force") {
    run_rlog <- F
    trafo_long_text <- "variance stabilizing transformation (vst)"
    nsub_genes_text <- paste0("The number of subset genes for the vst transformation was set to ", as.character(params$nsub_genes), ".")
    if (var_sizeFactors >= vst_cutoff) {
        trafo_override_text <- paste0(" This was due to using the `vst-force` argument. It is recommended to rerun the pipeline using the rlog transformation as the size factors of the different samples have a variance of ~", round(var_sizeFactors, 4), ". For high sample variances (i.e. different sequencing depths between samples), the rlog transformation is more suitable [@love2014differential].")
        nsub_genes_text <- ""
    }
} else if (params$trafo == "vst") {
    run_rlog <- F
    trafo_long_text <- "variance stabilizing transformation (vst)"
    nsub_genes_text <- paste0("The number of subset genes for the vst transformation was set to ", as.character(params$nsub_genes), ".")
    if (var_sizeFactors >= vst_cutoff) {
        run_rlog <- T
        trafo_long_text <- "regularized logarithm (rlog)"
        trafo_override_text <- paste0(" This was done as the size factors of the different samples have a variance of ~", round(var_sizeFactors, 4), ". For high sample variances (i.e. different sequencing depths between samples), the rlog transformation is more suitable [@love2014differential].")
        nsub_genes_text <- ""
    }
}
trafo_text <- ifelse(run_rlog, "rlog", "vst")

if (run_rlog){

    # rlog transformation
    rld <- rlog(cds, blind=FALSE)
    rld_names <- merge(x=gene_names, y=assay(rld), by.x = "Ensembl_ID", by.y="row.names")
    write.table(rld_names, "differential_gene_expression/gene_counts_tables/rlog_transformed_gene_counts.tsv", append = FALSE, quote = FALSE, sep = "\t",eol = "\n", na = "NA", dec = ".", row.names = F,  qmethod = c("escape", "double"))

    # save table to another variable if pathway analysis
    if (params$pathway_analysis) {
        norm_counts <- rld_names
        rownames(norm_counts) <- norm_counts$Ensembl_ID
    }

} else {

    # vst transformation
    vsd <- vst(cds, blind=FALSE, nsub = params$nsub_genes)
    vsd_names <- merge(x=gene_names, y=assay(vsd), by.x = "Ensembl_ID", by.y="row.names")
    write.table(vsd_names, "differential_gene_expression/gene_counts_tables/vst_transformed_gene_counts.tsv", append = FALSE, quote = FALSE, sep = "\t",eol = "\n", na = "NA", dec = ".", row.names = F, qmethod = c("escape", "double"))

    # save table to another variable if pathway analysis
    if (params$pathway_analysis) {
        norm_counts <- vsd_names
        rownames(norm_counts) <- norm_counts$Ensembl_ID
    }
}

############################## DIAGNOSTICS AND QUALITY CONTROL PLOTS ###############################
# Cooks distances: get important for example when checking knock-out and overexpression studies
pdf("differential_gene_expression/plots/further_diagnostics_plots/Cooks-distances.pdf")
par(mar=c(10,3,3,3))
par( mfrow = c(1,2))
boxplot(log10(assays(cds)[["cooks"]]), range=0, las=2,ylim = c(-15, 15),main="log10-Cooks")
boxplot(log2(assays(cds)[["cooks"]]), range=0, las=2,ylim = c(-15, 15),main="log2-Cooks")
dev.off()
png("differential_gene_expression/plots/further_diagnostics_plots/Cooks-distances.png")
par(mar=c(10,3,3,3))
par( mfrow = c(1,2))
boxplot(log10(assays(cds)[["cooks"]]), range=0, las=2,ylim = c(-15, 15),main="log10-Cooks")
boxplot(log2(assays(cds)[["cooks"]]), range=0, las=2,ylim = c(-15, 15),main="log2-Cooks")
dev.off()
svg("differential_gene_expression/plots/further_diagnostics_plots/Cooks-distances.svg")
par(mar=c(10,3,3,3))
par( mfrow = c(1,2))
boxplot(log10(assays(cds)[["cooks"]]), range=0, las=2,ylim = c(-15, 15),main="log10-Cooks")
boxplot(log2(assays(cds)[["cooks"]]), range=0, las=2,ylim = c(-15, 15),main="log2-Cooks")
dev.off()

# The function plotDispEsts visualizes DESeqs dispersion estimates:
pdf("differential_gene_expression/plots/further_diagnostics_plots/Dispersion_plot.pdf")
plotDispEsts(cds, ylim = c(1e-5, 1e8))
dev.off()
png("differential_gene_expression/plots/further_diagnostics_plots/Dispersion_plot.png")
plotDispEsts(cds, ylim = c(1e-5, 1e8))
dev.off()
svg("differential_gene_expression/plots/further_diagnostics_plots/Dispersion_plot.svg")
plotDispEsts(cds, ylim = c(1e-5, 1e8))
dev.off()

# Effects of transformations on the variance
notAllZero <- (rowSums(counts(cds))>0)
pdf("differential_gene_expression/plots/further_diagnostics_plots/Effects_of_transformations_on_the_variance.pdf")
par(oma=c(3,3,3,3))
par(mfrow = c(1, 3))
meanSdPlot(log2(counts(cds,normalized=TRUE)[notAllZero,] + 1),ylab  = "sd raw count data")
meanSdPlot(assay((if (run_rlog) rld else vsd)[notAllZero,]),ylab  = paste("sd", trafo_text, "transformed count data"))
dev.off()
notAllZero <- (rowSums(counts(cds))>0)
png("differential_gene_expression/plots/further_diagnostics_plots/Effects_of_transformations_on_the_variance.png")
par(oma=c(3,3,3,3))
par(mfrow = c(1, 3))
meanSdPlot(log2(counts(cds,normalized=TRUE)[notAllZero,] + 1),ylab  = "sd raw count data")
meanSdPlot(assay((if (run_rlog) rld else vsd)[notAllZero,]),ylab  = paste("sd", trafo_text, "transformed count data"))
dev.off()
notAllZero <- (rowSums(counts(cds))>0)
svg("differential_gene_expression/plots/further_diagnostics_plots/Effects_of_transformations_on_the_variance.svg")
par(oma=c(3,3,3,3))
par(mfrow = c(1, 3))
meanSdPlot(log2(counts(cds,normalized=TRUE)[notAllZero,] + 1),ylab  = "sd raw count data")
meanSdPlot(assay((if (run_rlog) rld else vsd)[notAllZero,]),ylab  = paste("sd", trafo_text, "transformed count data"))
dev.off()

# Further diagnostics plots
res=0
for (i in resultsNames(cds)[-1]) {
    res = results(cds,name = i)
    pdf(paste("differential_gene_expression/plots/further_diagnostics_plots/all_results_MA_plot_",i,".pdf",sep=""))
    plotMA(res,ylim = c(-4, 4))
    dev.off()
    png(paste("differential_gene_expression/plots/further_diagnostics_plots/all_results_MA_plot_",i,".png",sep=""))
    plotMA(res,ylim = c(-4, 4))
    dev.off()
    svg(paste("differential_gene_expression/plots/further_diagnostics_plots/all_results_MA_plot_",i,".svg",sep=""))
    plotMA(res,ylim = c(-4, 4))
    dev.off()

    # multiple hyptothesis testing
    qs <- c( 0, quantile(results(cds)$baseMean[res$baseMean > 0], 0:4/4 ))
    bins <- cut(res$baseMean, qs )

    # rename the levels of the bins using the middle point
    levels(bins) <- paste0("~",round(.5*qs[-1] + .5*qs[-length(qs)]))

    # calculate the ratio of p-values less than .01 for each bin
    ratios <- tapply(res$pvalue, bins, function(p) mean(p < .01, na.rm=TRUE ))

    # plot these ratios
    pdf(paste("differential_gene_expression/plots/further_diagnostics_plots/dependency_small.pval_mean_normal.counts_",i,".pdf",sep=""))
    barplot(ratios, xlab="mean normalized count", ylab="ratio of small p-values")
    dev.off()
    png(paste("differential_gene_expression/plots/further_diagnostics_plots/dependency_small.pval_mean_normal.counts_",i,".png",sep=""))
    barplot(ratios, xlab="mean normalized count", ylab="ratio of small p-values")
    dev.off()
    svg(paste("differential_gene_expression/plots/further_diagnostics_plots/dependency_small.pval_mean_normal.counts_",i,".svg",sep=""))
    barplot(ratios, xlab="mean normalized count", ylab="ratio of small p-values")
    dev.off()

    # plot number of rejections
    pdf(paste("differential_gene_expression/plots/further_diagnostics_plots/number.of.rejections_",i,".pdf",sep=""))
    plot(metadata(res)$filterNumRej,
        type="b", ylab="number of rejections",
        xlab="quantiles of filter")
    lines(metadata(res)$lo.fit, col="red")
    abline(v=metadata(res)$filterTheta)
    dev.off()
    png(paste("differential_gene_expression/plots/further_diagnostics_plots/number.of.rejections_",i,".png",sep=""))
    plot(metadata(res)$filterNumRej,
        type="b", ylab="number of rejections",
        xlab="quantiles of filter")
    lines(metadata(res)$lo.fit, col="red")
    abline(v=metadata(res)$filterTheta)
    dev.off()
    svg(paste("differential_gene_expression/plots/further_diagnostics_plots/number.of.rejections_",i,".svg",sep=""))
    plot(metadata(res)$filterNumRej,
        type="b", ylab="number of rejections",
        xlab="quantiles of filter")
    lines(metadata(res)$lo.fit, col="red")
    abline(v=metadata(res)$filterTheta)
    dev.off()

    # Histogram of passed and rejected hypothesis
    use <- res$baseMean > metadata(res)$filterThreshold
    table(use)
    h1 <- hist(res$pvalue[!use], breaks=0:50/50, plot=FALSE)
    h2 <- hist(res$pvalue[use], breaks=0:50/50, plot=FALSE)
    colori <- c('do not pass'="khaki", 'pass'="powderblue")
    pdf(paste("differential_gene_expression/plots/further_diagnostics_plots/histogram_of_p.values",i,".pdf",sep=""))
    barplot(height = rbind(h1$density, h2$density), beside = FALSE,
            col = colori, space = 0, main = "", xlab="p-value",ylab="frequency")
    text(x = c(0, length(h1$counts)), y = 0, label = paste(c(0,1)),
        adj = c(0.5,1.7), xpd=NA)
    legend("topleft", fill=rev(colori), legend=rev(names(colori)))
    dev.off()
    png(paste("differential_gene_expression/plots/further_diagnostics_plots/histogram_of_p.values",i,".png",sep=""))
    barplot(height = rbind(h1$density, h2$density), beside = FALSE,
            col = colori, space = 0, main = "", xlab="p-value",ylab="frequency")
    text(x = c(0, length(h1$counts)), y = 0, label = paste(c(0,1)),
        adj = c(0.5,1.7), xpd=NA)
    legend("topleft", fill=rev(colori), legend=rev(names(colori)))
    dev.off()
    svg(paste("differential_gene_expression/plots/further_diagnostics_plots/histogram_of_p.values",i,".svg",sep=""))
    barplot(height = rbind(h1$density, h2$density), beside = FALSE,
            col = colori, space = 0, main = "", xlab="p-value",ylab="frequency")
    text(x = c(0, length(h1$counts)), y = 0, label = paste(c(0,1)),
        adj = c(0.5,1.7), xpd=NA)
    legend("topleft", fill=rev(colori), legend=rev(names(colori)))
    dev.off()
    rm(res,qs,bins,ratios,use,h1,h2,colori)
}
```
<!-- DESeq2 end -->


<!-- multiQC start -->

```{r summary_stats, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")), results = 'asis'}
cat(paste0("***
# Read mapping and assignment

In order to analyze the gene counts per sample, the sequencing reads need to be mapped to the reference genome, and assigned to genes or other genomic regions.
Here, the read mapping and gene assignment statistics are summarized, among other read processing quality control parameters.
The read sequencing quality was analyzed using `FASTQC`. More detailed information is available in the `MultiQC` report of all samples available [here](./QC/multiqc_report.html).

## Summary statistics

The read mapping and gene assignment statistics, together with other quality control parameters are summarized here.

The table below, extracted from the `MultiQC` report, shows a summary of the bioinformatics analysis quality control.
Note: Duplicate intercept (%) is the percentage of duplicate reads for the intercept of a linear model of duplicate reads vs read counts. High numbers of duplicates at low read counts can indicate low library complexity with technical duplication."
))
df_DE <- read.table(file = paste0(wd,"/QC/multiqc_data/multiqc_general_stats.txt"), header=TRUE, sep="\t")
is.num <- sapply(df_DE, is.numeric)
df_DE[is.num] <- lapply(df_DE[is.num], round, 2)
columns <- c("Sample",
            "FastQC_mqc.generalstats.fastqc.total_sequences",
            "FastQC_mqc.generalstats.fastqc.percent_duplicates",
            "FastQC_mqc.generalstats.fastqc.percent_gc",
            "Cutadapt_mqc.generalstats.cutadapt.percent_trimmed",
            "STAR_mqc.generalstats.star.uniquely_mapped_percent",
            "featureCounts_mqc.generalstats.featurecounts.percent_assigned")
df_DE_selected <- df_DE[,columns]

# The following gets rid of multiQC entries that are spread across two rows, one ending with -fw (see https://github.com/qbic-pipelines/rnadeseq/issues/114)
sum_NA <- function(x) {if (all(is.na(x))) x[NA_integer_] else sum(x, na.rm = TRUE)}
df_DE_selected$Sample <- gsub("-fw", "", df_DE_selected$Sample)
df_DE_selected <- df_DE_selected %>% group_by(Sample) %>% summarise_all(sum_NA)


df_DE_selected$Sample <- substr(df_DE_selected$Sample, 1, 10)
colnames(df_DE_selected) <- c("Sample", "C1", "C2", "C3", "C4", "C5", "C6")
n_rows = nrow(df_DE_selected)

metadata <- read.table((paste0(wd, "/differential_gene_expression/metadata/metadata.tsv")), header=TRUE, sep="\t")
metadata = metadata[,c("QBiC.Code")]

#the following makes metadata a df again (in R, when extracting only 1 column from a df, it becomes a list)
metadata <- data.frame(matrix(unlist(metadata)))
colnames(metadata) <- c("Sample")
table_complete = merge(metadata,df_DE_selected,by="Sample")
colnames = c("Sample", "Number of reads (M)", "Duplicates (%)", "GC (%)", "Trimmed reads (%)", "Mapped reads (%)", "Assigned reads (%)")
colnames(table_complete) <- c("Sample", "C1", "C2", "C3", "C4", "C5", "C6")
table_complete %>%
    mutate(
        Sample = Sample,
        ReadNumber = color_bar("lightblue")(round((C1/1000000),2)),
        DuplicateReadsIntercept = ifelse(C2 > 1,
                                        cell_spec(C2, color="orange", bold=T),
                                        cell_spec(C2, color="black")),
        GCcontent = C3,
        TrimmedReads = C4,
        MappedReads =  ifelse(C5 > 80,
                            color_bar("lightblue")(C5),
                            color_bar("orange")(C5)),
        AssignedReads = ifelse(C6 > 60,
                            color_bar("lightblue")(C6),
                            color_bar("orange")(C6))
    ) %>%
    dplyr::select(1,8:13) %>%
    kable(escape=F,row.names=F, col.names=colnames) %>%
    kable_styling("hover") %>%
    scroll_box(width = "100%", height = "400px")

cat(paste0("***
Note: Duplicate intercept (%) is the percentage of duplicate reads for the intercept of a linear model of duplicate reads vs read counts. High numbers of duplicates at low read counts can indicate low library complexity with technical duplication.

\

## Mapping statistics {.tabset}

The read mapping statistics to the reference genome for each sample are shown below. Typical values for a good mapping lie at > 80 % uniquely mapped reads.

### Percentages {-}

<center>
"))
```

```{r STAR_percentages_plot, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")), out.width="160%", dpi=1800, fig.cap="STAR: Mapping Statistics", fig.align='center'}
knitr::include_graphics(paste0(wd, "/QC/multiqc_plots/svg/mqc_star_alignment_plot_1_pc.svg"))
```

```{r STAR_readnums,echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/"))}
cat(paste0("***
</center>
### Number of reads {-}
<center>
"))
```

```{r STAR_readnums_plot, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")), out.width="160%", dpi=1800, fig.cap="STAR: Mapping Statistics", fig.align='center'}
knitr::include_graphics(paste0(wd, "/QC/multiqc_plots/svg/mqc_star_alignment_plot_1.svg"))
```

```{r FC_read_assignment, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/"))}
cat(paste0("***
</center>
\

## Read assignment statistics {.tabset}

The statistics of read assignment to genes are shown below. Most reads should be assigned. Interpretation of the different assignment types:

-   **Assigned:** The reads could properly be assigned to a gene or feature. \
-   **Unassigned Ambiguity:** The reads could not be assigned to any gene because of its ambiguous character.
    This can be the case when e.g. a read maps
    to two different genes at the same time making the assignment ambiguous. \
-   **Unassigned MultiMapping:** The reads could not be assigned to any gene because they map to several distinct locations on the reference genome. \
-   **Unassigned NoFeatures:** The reads could not be assigned to any gene because their mapping position in the reference genome is not annotated.

### Percentages {-}

<center>
"))
```

```{r FC_percentages_plot, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")), out.width="160%", dpi=1200, fig.cap="featureCounts: Assignments", fig.align='center'}
knitr::include_graphics(paste0(wd, "/QC/multiqc_plots/svg/mqc_featureCounts_assignment_plot_1_pc.svg"))
```

```{r FC_readnums, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/"))}
cat(paste0("***
</center>

### Number of reads {-}

<center>
"))
```

```{r FC_readnums_plot, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")), out.width="160%", dpi=1200, fig.cap="featureCounts: Assignments", fig.align='center'}
knitr::include_graphics(paste0(wd, "/QC/multiqc_plots/svg/mqc_featureCounts_assignment_plot_1.svg"))
```

```{r read_feat_distrib, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/"))}
cat(paste0("***
</center>
\

## Read feature distribution {.tabset}

The read distribution of mapped reads over different genomic features (CDS exon, 5'UTR exon, 3' UTR exon, Intron, Intergenic regions) is shown below.
In RNAseq experiments, the majority of the reads should be assigned to CDS exons.

### Percentages {-}

<center>
"))
```

```{r RSeqC_percentages_plot, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")), out.width="160%", dpi=1200, fig.cap="RSeQC: Read Distribution", fig.align='center'}
knitr::include_graphics(paste0(wd, "/QC/multiqc_plots/svg/mqc_rseqc_read_distribution_plot_1_pc.svg"))
```

```{r RSeqC_readnums, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/"))}
cat(paste0("***
</center>

### Number of reads {-}

<center>
"))
```

```{r RSeqC_readnums_plot, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/")), out.width="160%", dpi=1200, fig.cap="RSeQC: Read Distribution", fig.align='center'}
knitr::include_graphics(paste0(wd, "/QC/multiqc_plots/svg/mqc_rseqc_read_distribution_plot_1.svg"))
```

```{r MQC_end, echo=FALSE, message=FALSE, warning=FALSE, results='asis', eval=dir.exists(paste0(wd,"/QC/multiqc_data/"))}
cat(paste0("***
</center>
\
"))
```

<!-- multiQC end -->

# Gene expression data

## Raw and normalized count tables

The raw count table and normalized count tables are available [here](./differential_gene_expression/gene_counts_tables).
The differential expression analysis is performed using the raw gene count table.
For PCA analysis and heatmap plotting, the `r trafo_long_text` normalized gene counts were used. 
`r trafo_override_text`
`r nsub_genes_text`

## Principal component analysis (PCA)

A PCA plot of the `r trafo_text` normalized gene expression visualizes the clustering of samples according to their gene expression.
In this way, the overall effect of experimental conditions and sample grouping, and any batch effects are visualized.
The original plot can be downloaded [here](./differential_gene_expression/plots/PCA_plot.pdf).

\

```{r PCA_ifNoBatch_plot, echo=F, message=F, warning=F, out.width="80%", dpi=1200, fig.align='center'}
############################ PCA PLOTS ########################
pcaData <- plotPCA(if (run_rlog) rld else vsd,intgroup=c("combfactor"), ntop=dim(if (run_rlog) rld else vsd)[1], returnData=TRUE)
percentVar <- round(100*attr(pcaData, "percentVar"))
pca <- ggplot(pcaData, aes(PC1, PC2, color=combfactor, text=paste("Sample: ", name, "<br>", "PC1: ", PC1, "<br>", "PC2: ", PC2))) +
    geom_point(size=3) +
    xlab(paste0("PC1: ",percentVar[1],"% variance")) +
    ylab(paste0("PC2: ",percentVar[2], "% variance")) +
    coord_fixed() +
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

# Save static plot without labels
ggsave(plot = pca, filename = "differential_gene_expression/plots/PCA_plot.pdf", device = "pdf", dpi = 300)
ggsave(plot = pca, filename = "differential_gene_expression/plots/PCA_plot.svg", device = "svg", dpi = 150)
ggsave(plot = pca, filename = "differential_gene_expression/plots/PCA_plot.png", device = "png", dpi = 150)

# Save static plot with samplename labels
pca_with_labels <- pca +
    geom_label_repel(aes(label=name), force=2, force_pull=0, size=2.8, box.padding=0.15,show.legend  = F)
ggsave(plot = pca_with_labels, filename = "differential_gene_expression/plots/PCA_plot_with_labels.pdf", device = "pdf", dpi = 300)
ggsave(plot = pca_with_labels, filename = "differential_gene_expression/plots/PCA_plot_with_labels.svg", device = "svg", dpi = 150)
ggsave(plot = pca_with_labels, filename = "differential_gene_expression/plots/PCA_plot_with_labels.png", device = "png", dpi = 150)

# Create interactive plot for report
pca <- ggplotly(pca, tooltip = "text", width=750, height=400)

#add export-as-SVG button to plot
config(pca, modeBarButtonsToAdd = list(svg_exp)) %>% layout()
```

\

```{r batch_text, echo=F, message=F, warning=F, eval=params$batch_effect, results='asis'}
cat("Batch effects were observed in the PCA, so batch effects were corrected.
A PCA of the batch-effect corrected data is shown below and can be found [here](./differential_gene_expression/plots/PCA_batch_corrected_plot.pdf)")
```

```{r PCA_ifBatch_plot, echo=F, message=F, warning=F, dpi=1200, fig.align='center', eval=params$batch_effect}
if (run_rlog) {
    assay(rld) <- limma::removeBatchEffect(assay(rld), rld$batch)
} else {
    assay(vsd) <- limma::removeBatchEffect(assay(vsd), vsd$batch)
}
pcaData2 <- plotPCA(if (run_rlog) rld else vsd, intgroup=c("combfactor"), ntop = dim(if (run_rlog) rld else vsd)[1], returnData=TRUE)
percentVar <- round(100*attr(pcaData, "percentVar"))
pca2 <- ggplot(pcaData2, aes(PC1, PC2, color=combfactor, text=paste("Sample: ", name, "<br>", "PC1: ", PC1, "<br>", "PC2: ", PC2))) +
    geom_point(size=3)+
    xlab(paste0("PC1: ", percentVar[1],"% variance")) +
    ylab(paste0("PC2: ", percentVar[2], "% variance")) +
    coord_fixed() +
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

# Save static plot without labels
ggsave(plot = pca2, filename = "differential_gene_expression/plots/PCA_batch_corrected_plot.pdf", device = "pdf", dpi=300)
ggsave(plot = pca2, filename = "differential_gene_expression/plots/PCA_batch_corrected_plot.svg", device = "svg", dpi = 150)
ggsave(plot = pca2, filename = "differential_gene_expression/plots/PCA_batch_corrected_plot.png", device = "png", dpi = 150)

# Save static plot with samplename labels

pca2_with_labels <- pca2 +
    geom_label_repel(aes(label=name), force=2, force_pull=0, size=2.8, box.padding=0.15,show.legend  = F)
ggsave(plot = pca2_with_labels, filename = "differential_gene_expression/plots/PCA_batch_corrected_plot_with_labels.pdf", device = "pdf", dpi = 300)
ggsave(plot = pca2_with_labels, filename = "differential_gene_expression/plots/PCA_batch_corrected_plot_with_labels.svg", device = "svg", dpi = 150)
ggsave(plot = pca2_with_labels, filename = "differential_gene_expression/plots/PCA_batch_corrected_plot_with_labels.png", device = "png", dpi = 150)

# Create interactive plot for report
pca2 <- ggplotly(pca2, tooltip = "text", width=750, height=400)

#add export-as-SVG button to plot
config(pca2, modeBarButtonsToAdd = list(svg_exp)) %>% layout()
```

## Sample distance heatmap

A sample distance heatmap was generated from the distances of the normalized expression values for all samples.

This visualizes how similar the samples are to each other according to gene expression.
Two samples have more similar gene expression if their distance is closer to 0 (darker blue).
The original plot can be downloaded [here](./differential_gene_expression/plots/Heatmaps_of_distances.pdf).

```{r heatmap_calculate, include=FALSE}
##################  SAMPLE DISTANCES HEATMAP ##################
# Sample distances, this chunk is hidden as otherwise, the heatmap is shown multiple times
sampleDists <- dist(t(assay(if (run_rlog) rld else vsd)))
sampleDistMatrix <- as.matrix(sampleDists)
colors = colorRampPalette(rev(RColorBrewer::brewer.pal(9, "Blues")))(255)
par(oma=c(3,3,3,3))
dist_heatmap <- heatmaply(sampleDistMatrix, dendrogram = "both", col=colors, grid_color = "grey")
save_image(dist_heatmap, file="differential_gene_expression/plots/Heatmaps_of_distances.pdf")
save_image(dist_heatmap, file="differential_gene_expression/plots/Heatmaps_of_distances.png")
save_image(dist_heatmap, file="differential_gene_expression/plots/Heatmaps_of_distances.svg")
```

```{r heatmap_show, echo=FALSE, message=FALSE, warning=FALSE, out.width="90%", out.height="130%", fig.asp=1, dpi=1000, fig.align='center'}
#add export button to plot
dist_heatmap %>% layout(height=700, width=800) %>% config(modeBarButtonsToAdd = list(svg_exp))
```

# Differential expression analysis

After unzipping the results ZIP file, the differential expression results can be found in the directory [differential_gene_expression/](./differential_gene_expression), containing the following subfolders:

```{r structure_strings, echo=FALSE, message=FALSE, warning=FALSE}

# Change the different strings depending on which input_type and transformation was used
    featurecounts_string <- ifelse(params$input_type == "featurecounts", "
    - `raw_gene_counts.txt`: raw gene counts table from the nf-core/rnaseq pipeline; used for the differential gene expression analysis.", "")
    rsem_salmon_string <- ifelse(params$input_type %in% c("rsem", "salmon"), paste0("- `star_", params$input_type, "_files.txt`: list of ", ifelse(params$input_type == "rsem", "RSEM counts files", "Salmon quantification files"), " that were provided as input; used for the differential gene expression analysis."), "")
    genecounts_string <- ifelse(run_rlog, '- `rlog_transformed_gene_counts.tsv`: normalized gene counts with the "regularized logarithm" approach. This normalization is used prior to PCA analysis and heatmap plotting of the gene counts.', '- `vst_transformed_gene_counts.tsv`: normalized gene counts with the "variance stabilizing" transformation.')
```

<br><details>
<summary>Expand/collapse</summary>
- `metadata/`
    - `metadata.tsv`: metadata sheet used by the pipeline.
    - `contrasts.tsv`: contrasts used for DE analysis (if provided).
    - `linear_model.txt`: linear model used for DE analysis.
    - `gene_list.txt`: provided list of interesting genes (if provided).
    `r rsem_salmon_string`
- `gene_counts_tables/`
    `r featurecounts_string`
    - `deseq2_library_scaled_gene_counts.tsv`: gene counts after size factor scaling.
    `r genecounts_string`
    - `sizeFactor_libraries.tsv`: size factors for each sample.
- `DE_genes_tables/`: folder containing one tab-separated table for each of the contrasts in the analysis. Each table contains a list of all differentially expressed genes in the contrast, specifying the mean gene expression across all samples (baseMean), and the log2 fold change value and p-adjusted values (padj) for this contrast.
- `final_gene_table/final_gene_list_DESeq2.tsv`: table containing a list of all genes considered in the analysis. Here a summary of the log2 Fold Change and p-adjusted values for all contrasts is displayed. Additionally, the column **filter** shows if this gene was differentially expressed (DE) in any of the contrasts, or not (not_DE). The column **contrast_vector** contains for each contrast considered in the analysis a 1 if the gene was differentially expressed for this contrast or a 0 if it was not.
- `plots/`:
    - `Heatmaps_of_distances.pdf/.svg`: heatmap of the pairwise euclidean distances among samples, when the `r trafo_text` normalized gene counts are considered.
    - `PCA_plot.pdf`: PCA of the `r trafo_text` normalized gene counts.
    - `boxplots_example_genes/`: boxplots of the normalized gene counts for each of the sample groups for example genes.
    - `boxplots_requested_genes/`: boxplots of the normalized gene counts for each of the sample groups for the list of requested genes.
    - `further_diagnostics_plots/`: plots for diagnostics of the differential gene analysis procedure.
</details><br>

To perform differential gene expression analysis, the gene expression data between two sample groups is compared.
These comparisons are called _contrasts_. For this analysis, the following contrasts or comparisons were made:

<!-- contrast calculation start -->
```{r contrast_calc, echo=FALSE, message=FALSE, warning=FALSE, results = 'hide'}

# Contrasts coefficient table write in metadata
coefficients <- resultsNames(cds)
coef_tab <- data.frame(coef=coefficients)
write.table(coef_tab,file="differential_gene_expression/metadata/DESeq2_coefficients.tsv", sep="\t", quote=F, col.names = T, row.names = F)

# Start variables to store DE genes for all contrasts
DE_genes_df = data.frame(DE_genes_df = character(nrow(cds)))
contrast_names <- c()
if (isProvided(params$path_contrast_matrix)){
    contrasts <- read.table(params$path_contrast_matrix, sep="\t", header = T, row.names = 1)

    # Remove batch as this should normally not be considered a contrast
    contrasts <- contrasts[!startsWith(row.names(contrasts), "batch"),]

    # to get all possible pairwise comparisons, make a combined factor
    for (c in 1:length(conditions_contrasts)) {
        if (grepl("condition_", colnames(metadata_save)[c], fixed = TRUE) && !(any(grepl(paste0("^", (colnames(metadata_save)[c])), rownames(contrasts))))) {
            conditions_contrasts[c] <- FALSE
        }
    }
    metadata_save$combfactor_contrasts <- apply(as.data.frame(metadata_save[ ,conditions_contrasts]),1,paste, collapse = "_")
    write.table(contrasts, file="differential_gene_expression/metadata/contrast_matrix.tsv", sep="\t", quote=F, col.names = T, row.names = F)

    # Check that contrast matrix is valid
    if (length(coefficients) != nrow(contrasts)){
        stop("Error: Your contrast table has a different number of rows than the number of coefficients in the DESeq2 model.")
    }

    ## Contrast calculation for contrast matrix
    for (i in c(1:ncol(contrasts))) {
        results_DEseq_contrast <-results(cds, contrast=contrasts[[i]])
        contname <- names(contrasts[i])
        results_DEseq_contrast <- as.data.frame(results_DEseq_contrast)
        print("Analyzing contrast:")
        print(contname)

        # Add gene name in table
        DE_genes_contrast_genename <- results_DEseq_contrast
        DE_genes_contrast_genename$Ensembl_ID = row.names(results_DEseq_contrast)
        DE_genes_contrast_genename <- merge(x=DE_genes_contrast_genename, y=gene_names, by.x = "Ensembl_ID", by.y="Ensembl_ID", all.x=T)
        DE_genes_contrast_genename = DE_genes_contrast_genename[,c(dim(DE_genes_contrast_genename)[2],1:dim(DE_genes_contrast_genename)[2]-1)]
        DE_genes_contrast_genename = DE_genes_contrast_genename[order(DE_genes_contrast_genename[,"Ensembl_ID"]),]

        # Save all DE genes (even if not significant) to separate files for the volcano plot
        write.table(DE_genes_contrast_genename, file=paste("differential_gene_expression/allgenes/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)

        # Select only significantly DE
        DE_genes_contrast <- subset(DE_genes_contrast_genename, padj <= params$adj_pval_threshold & abs(log2FoldChange) >= params$logFC_threshold)
        DE_genes_contrast <- DE_genes_contrast[order(DE_genes_contrast$padj),]
        # Round table before writing
        if (isProvided(params$round_DE)) {
            DE_genes_contrast <- (DE_genes_contrast  %>% mutate_if(is.numeric, round, digits=params$round_DE))
        }
        # Save table
        write.table(DE_genes_contrast, file=paste("differential_gene_expression/DE_genes_tables/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)
        names(results_DEseq_contrast) = paste(names(results_DEseq_contrast),contname,sep="_")

        # Append to DE genes table for all contrasts
        DE_genes_df = cbind(DE_genes_df,results_DEseq_contrast)
    }
    contrast_names <- append(contrast_names, colnames(contrasts))
}
if (isProvided(params$path_contrast_list)) {
    contrasts <- read.table(params$path_contrast_list, sep="\t", header=T, colClasses = "character")

    # Remove batch as this should normally not be considered a contrast
    contrasts <- contrasts[!startsWith(contrasts$factor, "batch"),]

    # to get all possible pairwise comparisons, make a combined factor
    for (c in 1:length(conditions_contrasts)) {
        if (grepl("condition_", colnames(metadata_save)[c], fixed = TRUE) & !(colnames(metadata_save)[c] %in% contrasts$factor) ) {
            conditions_contrasts[c] <- FALSE
        }
    }
    metadata_save$combfactor_contrasts <- apply(as.data.frame(metadata_save[ ,conditions_contrasts]),1,paste, collapse = "_")

    for (i in 1:nrow(contrasts)) {
        if (grepl("condition_", contrasts[i,1], fixed = TRUE)) {
            cond_name <- contrasts[i,1]
            for (j in 2:ncol(contrasts)) {
                if (!any(metadata_save[cond_name]==contrasts[i,j])) {
                    stop(paste("Could not find value", contrasts[i,j], "for contrast", metadata_save[cond_name], ", please check metadata sheet and contrast list!"))
                }
            }
        }
    }
    write.table(contrasts, file="differential_gene_expression/metadata/contrast_list.tsv", quote=F)

    ## Contrast calculation for contrast list
    for (i in c(1:nrow(contrasts))) {
        cont <- as.character(contrasts[i,])
        contname <- paste0(cont[1], "_", cont[2], "_vs_", cont[3])
        results_DEseq_contrast <- results(cds, contrast=cont)
        results_DEseq_contrast <- as.data.frame(results_DEseq_contrast)
        print(contname)

        # Add gene name in table
        DE_genes_contrast_genename <- results_DEseq_contrast
        DE_genes_contrast_genename$Ensembl_ID = row.names(results_DEseq_contrast)
        DE_genes_contrast_genename <- merge(x=DE_genes_contrast_genename, y=gene_names, by.x = "Ensembl_ID", by.y="Ensembl_ID", all.x=T)
        DE_genes_contrast_genename = DE_genes_contrast_genename[,c(dim(DE_genes_contrast_genename)[2],1:dim(DE_genes_contrast_genename)[2]-1)]
        DE_genes_contrast_genename = DE_genes_contrast_genename[order(DE_genes_contrast_genename[,"Ensembl_ID"]),]

        # Save all DE genes (even if not significant) to separate files for the volcano plot
        write.table(DE_genes_contrast_genename, file=paste("differential_gene_expression/allgenes/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)

        # Select only significantly DE
        DE_genes_contrast <- subset(DE_genes_contrast_genename, padj <= params$adj_pval_threshold & abs(log2FoldChange) >= params$logFC_threshold)
        DE_genes_contrast <- DE_genes_contrast[order(DE_genes_contrast$padj),]
        # Round table before writing
        if (isProvided(params$round_DE)) {
            DE_genes_contrast <- (DE_genes_contrast  %>% mutate_if(is.numeric, round, digits=params$round_DE))
        }
        # Save table
        write.table(DE_genes_contrast, file=paste("differential_gene_expression/DE_genes_tables/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)
        names(results_DEseq_contrast) = paste(names(results_DEseq_contrast),contname,sep="_")

        # Append to DE genes table for all contrasts
        DE_genes_df = cbind(DE_genes_df,results_DEseq_contrast)
        contrast_names <- append(contrast_names, contname)
    }
}
if (isProvided(params$path_contrast_pairs)) {
    contrasts <- read.table(path_contrast_pairs, sep="\t", header = T, colClasses = "character")
    write.table(contrasts, file="differential_gene_expression/metadata/contrast_pairs.tsv", sep="\t", quote=F, col.names = T, row.names = F)

    # Contrast calculation for contrast pairs
    for (i in c(1:nrow(contrasts))) {
        cont <- as.character(contrasts[i,])
        contname <- cont[0]
        if (!(cont[2] %in% coefficients & cont[3] %in% coefficients)){
            stop(paste("Provided contrast name is invalid, it needs to be contained in", coefficients))
        }
        results_DEseq_contrast <- results(cds, contrast=list(cont[1],cont[2]))
        results_DEseq_contrast <- as.data.frame(results_DEseq_contrast)
        print("Analyzing contrast:")
        print(contname)

        # Add gene name in table
        DE_genes_contrast_genename <- results_DEseq_contrast
        DE_genes_contrast_genename$Ensembl_ID = row.names(results_DEseq_contrast)
        DE_genes_contrast_genename <- merge(x=DE_genes_contrast_genename, y=gene_names, by.x = "Ensembl_ID", by.y="Ensembl_ID", all.x=T)
        DE_genes_contrast_genename = DE_genes_contrast_genename[,c(dim(DE_genes_contrast_genename)[2],1:dim(DE_genes_contrast_genename)[2]-1)]
        DE_genes_contrast_genename = DE_genes_contrast_genename[order(DE_genes_contrast_genename[,"Ensembl_ID"]),]

        # Save all DE genes (even if not significant) to separate files for the volcano plot
        write.table(DE_genes_contrast_genename, file=paste("differential_gene_expression/allgenes/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)

        # Select only significantly DE
        DE_genes_contrast <- subset(DE_genes_contrast_genename, padj <= params$adj_pval_threshold & abs(log2FoldChange) >= params$logFC_threshold)
        DE_genes_contrast <- DE_genes_contrast[order(DE_genes_contrast$padj),]

        # Round table before writing
        if (isProvided(params$round_DE)) {
            DE_genes_contrast <- (DE_genes_contrast  %>% mutate_if(is.numeric, round, digits=params$round_DE))
        }

        # Save table
        write.table(DE_genes_contrast, file=paste("differential_gene_expression/DE_genes_tables/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)
        names(results_DEseq_contrast) = paste(names(results_DEseq_contrast),contname,sep="_")

        # Append to DE genes table for all contrasts
        DE_genes_df = cbind(DE_genes_df,results_DEseq_contrast)
        contrast_names <- append(contrast_names, contname)
    }
}

# Calculating DE genes for default contrasts (no contrast matrix or list or pairs provided)
if (!isProvided(params$path_contrast_matrix) & !isProvided(params$path_contrast_list) & !isProvided(params$path_contrast_pairs)) {
    contrast_names <- coefficients[2:length(coefficients)]
    contrast_names <- contrast_names[!startsWith(contrast_names, "batch_")]
    for (contname in contrast_names) {

        results_DEseq_contrast <- results(cds, name=contname)
        results_DEseq_contrast <- as.data.frame(results_DEseq_contrast)
        print("Analyzing contrast:")
        print(contname)

        # Adding gene name to table
        DE_genes_contrast_genename <- results_DEseq_contrast
        DE_genes_contrast_genename$Ensembl_ID = row.names(results_DEseq_contrast)
        DE_genes_contrast_genename <- merge(x=DE_genes_contrast_genename, y=gene_names, by.x ="Ensembl_ID", by.y="Ensembl_ID", all.x=T)
        DE_genes_contrast_genename = DE_genes_contrast_genename[,c(dim(DE_genes_contrast_genename)[2],1:dim(DE_genes_contrast_genename)[2]-1)]
        DE_genes_contrast_genename = DE_genes_contrast_genename[order(DE_genes_contrast_genename[,"Ensembl_ID"]),]

        # Save all DE genes (even if not significant) to separate files for the volcano plot
        write.table(DE_genes_contrast_genename, file=paste("differential_gene_expression/allgenes/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)

        # Select only significantly DE
        DE_genes_contrast <- subset(DE_genes_contrast_genename, padj <= params$adj_pval_threshold & abs(log2FoldChange) >= params$logFC_threshold)
        DE_genes_contrast <- DE_genes_contrast[order(DE_genes_contrast$padj),]
        # Round table before writing
        if (isProvided(params$round_DE)) {
            DE_genes_contrast <- (DE_genes_contrast  %>% mutate_if(is.numeric, round, digits=params$round_DE))
        }
        # Save table
        write.table(DE_genes_contrast, file=paste("differential_gene_expression/DE_genes_tables/DE_contrast_",contname,".tsv",sep=""), sep="\t", quote=F, col.names = T, row.names = F)
        names(results_DEseq_contrast) = paste(names(results_DEseq_contrast),contname,sep="_")

        # Append to DE genes table for all contrasts
        DE_genes_df = cbind(DE_genes_df,results_DEseq_contrast)
    }
}

# Write contrast names to file
write(contrast_names, file="contrast_names.txt", sep="\t")

# Remove identical columns of DE_genes_df
DE_genes_df$DE_genes_df <- NULL
idx <- duplicated(t(DE_genes_df))
DE_genes_df <- DE_genes_df[, !idx]
DE_genes_df$Ensembl_ID <- row.names(DE_genes_df)
DE_genes_df <- DE_genes_df[,c(dim(DE_genes_df)[2],1:dim(DE_genes_df)[2]-1)]
names(DE_genes_df)[1:2] = c("Ensembl_ID","baseMean")

# Get DE genes from any contrast
padj_cols=names(DE_genes_df)[grepl("padj",names(DE_genes_df))]
logFC_cols = names(DE_genes_df)[grepl("log2FoldChange", names(DE_genes_df))]
logFC = DE_genes_df[,logFC_cols,drop=F]
padj = DE_genes_df[,padj_cols,drop=F]
padj[is.na(padj)] <- 1

# Convert to binary (1/0) matrix if padj <= params$adj_pval_threshold or not, respectively
padj_bin = data.matrix(ifelse(padj <= params$adj_pval_threshold, 1, 0))

# Convert to binary (1/0) matrix if logFC is bigger/equal or smaller/equal than threshold or not, respectively
logFC_bin = data.matrix(ifelse(abs(logFC) >= params$logFC_threshold, 1, 0))
# Multiply the two bin matrices --> if padj matrix value or LogFC matrix value is 0, will be 0

DE_bin = padj_bin * logFC_bin

# Save as data frame
DE_bin = as.data.frame(DE_bin)
cols <- names(padj)

# Contrast vector column -> contains 1 or 0 if gene was DE for each contrast
if (ncol(DE_bin)>1){
    DE_bin$contrast_vector <- apply(DE_bin[ ,cols],1,paste, collapse = "-")
    DE_bin$Ensembl_ID = row.names(padj)
} else {
    DE_bin$contrast_vector <- DE_bin[,1]
    DE_bin$Ensembl_ID = row.names(padj)
}
DE_bin = DE_bin[,c("Ensembl_ID","contrast_vector")]

# Add contrast vector to final DE genes data frame
DE_genes_final_table = merge(DE_genes_df,DE_bin,by.x="Ensembl_ID",by.y="Ensembl_ID")
stopifnot(identical(dim(DE_genes_final_table)[1],dim(assay(cds))[1]))

# Calculate outcome --> if gene is DE in any contrast, annotate as DE
DE_genes_final_table$outcome = ifelse(grepl("1",DE_genes_final_table$contrast_vector),"DE","not_DE")
DE_genes_final_table = merge(x=DE_genes_final_table, y=gene_names, by.x="Ensembl_ID", by.y="Ensembl_ID", all.x = T)
DE_genes_final_table = DE_genes_final_table[,c(dim(DE_genes_final_table)[2],1:dim(DE_genes_final_table)[2]-1)]
DE_genes_final_table = DE_genes_final_table[order(DE_genes_final_table[,"Ensembl_ID"]),]
# Round table before writing
if (isProvided(params$round_DE)) {
    DE_genes_final_table <- (DE_genes_final_table  %>% mutate_if(is.numeric, round, digits=params$round_DE))
}

#write to file
write.table(DE_genes_final_table, "differential_gene_expression/final_gene_table/final_DE_gene_list.tsv", append = FALSE, quote = FALSE, sep = "\t",eol = "\n", na = "NA", dec = ".", row.names = F,  col.names = T, qmethod = c("escape", "double"))
```
<!-- contrast calculation end -->

```{r print_contrasts, echo=FALSE, results='asis'}
for (i in 1:length(contrast_names)){
    cat(paste("* ", contrast_names[i], "\n"))
}
```

```{r load_config, bootstrap.show.message=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
logFC_text <- as.character(params$logFC_threshold)
pval_text <- as.character(params$adj_pval_threshold)
```

## List of differentially expressed genes

The analysis of the differential gene expression was performed using `DESeq2`.
Genes were considered differentially expressed (DE) when the adjusted p-value was equal to or lower than `r pval_text` (padj <= `r pval_text`).
Genes were further considered differentially expressed (DE) if the log2 Fold Change in expression between the two considered groups was equal to or above the threshold of `r logFC_text` in absolute terms.
The adjusted p-value is calculated in the `DESeq2` package with the Benjamini-Hochberg method. P-value adjustment
helps reduce the number of false postives (not real differentially expressed genes).

The linear model employed to model gene expression in DESeq2 was:
```{r print_model}
cat(paste(readLines(params$path_design), collapse=" "))
```

The differentially expressed genes are marked with "DE" in the outcome column if they were found
differentially expressed for any of the contrasts considered.

The table for download can be found [here](./differential_gene_expression/final_gene_table/final_DE_gene_list.tsv).

Additional tables for all individual contrasts are provided [here](./differential_gene_expression/DE_genes_tables).

## Volcano plots of DE genes

Volcano plots display the DE genes in Log2 Fold Change values (x axis)
against their adjusted p-value (y axis) in a form of a -log10. Only DE genes are colored red.
Genes were considered DE with a padj <= `r pval_text` (horizontal drawn through line) and in addition a Log2FC >= `r logFC_text` or <= -`r logFC_text` (vertical grey lines). Values above the horizontal dashed line were capped.
Here, volcano plots for all considered contrasts are shown. Hover over the dots to show the gene names.

```{r volcano_plot, out.width="100%", out.height="100%"}

# Set plot theme
theme_set(theme_bw(base_family = "ArialMT") +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(family="ArialMT")))
allgenes_files <- list.files(path=paste0(wd, "/differential_gene_expression/allgenes/"))
table_list <- list()

#Use allgenes files for volcano plots to also show non-DE genes
for (file in allgenes_files){

    #Reading DE genes list
    fname <- tools::file_path_sans_ext(basename(file))
    DE_genes <- read.csv(file = paste0(wd, "/differential_gene_expression/allgenes/", file), sep="\t", header = T)
    DE_genes$contrast <- rep(fname, nrow(DE_genes))

    # label: gene_name
    # x: log2FoldChange
    # y: -log10(padj)
    table_list <- append(table_list, list(DE_genes))
}
DE_all <- ldply(table_list, rbind)
DE_all$logpval <- -log10(DE_all$padj)
DE_all$logpval[DE_all$logpval > 16] <- 17
DE_all <- na.omit(DE_all)
log2FoldChange_min <- min(DE_all$log2FoldChange)
log2FoldChange_max <- max(DE_all$log2FoldChange)

# get quotient of log2FoldChange range and 10 to determine if xticks of plot need to be scaled discretely (otherwise, for large FC ranges, there will be too many xticks and they will overlap)
log2FoldChange_quotient <- length(seq(log2FoldChange_min, log2FoldChange_max, 10))

pg <- ggplot(DE_all, aes(x=log2FoldChange, y=logpval, text=paste("Gene: ", gene_name, "<br>", "Log2FC: ", formatC(log2FoldChange, digits=2)))) +
        #this goes after alpha=0.5:
        geom_jitter(alpha=0.5, width = 0.2, aes(color=ifelse(abs(DE_all$log2FoldChange) >= params$logFC_threshold &  DE_all$logpval >= -log10(params$adj_pval_threshold), "Differentially expressed genes", "Non-differentially expressed genes"))) +
        geom_hline(yintercept = 16, linetype= "dashed", size = 0.2, color = "grey") +
        geom_hline(yintercept = -log10(params$adj_pval_threshold), size = 0.2, color = "grey") +
        geom_vline(xintercept = -params$logFC_threshold, size = 0.2, color = "grey") +
        geom_vline(xintercept = params$logFC_threshold, size = 0.2, color = "grey") +
        scale_color_manual(name = "", values=c("red", "black")) +
        scale_y_continuous(limits = c(1, 18)) +
        facet_wrap(~contrast, ncol=1, scales = "free_x", shrink = FALSE) +
        ylab("-log 10 padj") + xlab("Log2 Fold Change") +
        theme(panel.spacing = unit(ifelse(length(allgenes_files)>2, 0.1, 0.6), "lines")) +
        scale_x_continuous(breaks = seq(-200, 200, ifelse(log2FoldChange_quotient<3, 1, 5)))

pg <- ggplotly(pg, tooltip = "text")
pg[['x']][['layout']][['annotations']][[2]][['x']] <- -params$adj_pval_threshold #-0.05 TODO: what do these two lines do?
pg[['x']][['layout']][['annotations']][[1]][['y']] <- -params$adj_pval_threshold

#add export button to plot
config(pg, modeBarButtonsToAdd = list(svg_exp)) %>% layout(margin = list(l=80, b = ifelse(length(allgenes_files)>2, 150, 100)), width=700, height = 500*length(allgenes_files))
```

```{r box_plots, echo=F, message =F}

############### BOXPLOTS GENE EXPRESSION PER CONDITION ##########################
# extract ID for genes to plot, make 20 plots:
DE_genes_plot <- subset(DE_genes_final_table, outcome == "DE")
DE_genes_plot = unique(DE_genes_plot$Ensembl_ID)
if (length(DE_genes_plot) > 20) {
    random_DE_genes_plot = sample(DE_genes_plot,size = 2)
} else {
    random_DE_genes_plot = DE_genes_plot
}
for (i in random_DE_genes_plot){
    colData(cds)$combfactor_contrasts <- apply(as.data.frame(metadata_save[ ,conditions_contrasts]),1,paste, collapse = "_")
    boxplot_counts <- plotCounts(cds, gene=i, intgroup=c("combfactor_contrasts"), returnData=TRUE, normalized = T)
    boxplot_counts$variable = row.names(boxplot_counts)
    plot <- ggplot(data=boxplot_counts, aes(x=combfactor_contrasts, y=count, fill=combfactor_contrasts)) +
                geom_boxplot(position=position_dodge()) +
                geom_jitter(position=position_dodge(.8)) +
                ggtitle(paste("Gene ",i,sep="")) + xlab("") + ylab("Normalized gene counts") + theme_bw() +
                theme(text = element_text(size=12),
                axis.text.x = element_text(angle=45, vjust=1,hjust=1))
    ggsave(filename=paste("differential_gene_expression/plots/boxplots_example_genes/",i,".svg",sep=""), width=10, height=5, plot=plot)
    ggsave(filename=paste("differential_gene_expression/plots/boxplots_example_genes/",i,".png",sep=""), width=10, height=5, plot=plot)
    ggsave(filename=paste("differential_gene_expression/plots/boxplots_example_genes/",i,".pdf",sep=""), width=10, height=5, plot=plot)
}

# make boxplots of interesting genes in gene list
if (isProvided(params$path_genelist)){
    gene_ids <- read.table(params$path_genelist, col.names = "requested_gene_name")
    write.table(gene_ids, file="differential_gene_expression/metadata/requested_gene_list.txt", col.names=F, row.names=F, sep="\t")
    gene_ids$requested_gene_name <- sapply(gene_ids$requested_gene_name, toupper)
    gene_names$gene_name <- sapply(gene_names$gene_name, toupper)

    # get Ensemble IDs from requested genes
    requested_genes_plot <- subset(gene_names, gene_name %in% gene_ids$requested_gene_name)

    # Check that genes are in the cds table
    requested_genes_plot <- subset(requested_genes_plot, requested_genes_plot$Ensembl_ID %in% row.names(cds))
    requested_genes_plot_Ensembl <- requested_genes_plot$Ensembl_ID
    requested_genes_plot_gene_name <- requested_genes_plot$gene_name
    for (i in seq_along(requested_genes_plot_Ensembl)) {
        boxplot_counts <- plotCounts(cds, gene=requested_genes_plot_Ensembl[i], intgroup=c("combfactor_contrasts"), returnData=TRUE, normalized = T)
        boxplot_counts$variable = row.names(boxplot_counts)
        plot <- ggplot(data=boxplot_counts, aes(x=combfactor_contrasts, y=count, fill=combfactor_contrasts)) +
        geom_boxplot(position=position_dodge()) +
        geom_jitter(position=position_dodge(.8)) +
        ggtitle(paste("Gene ",requested_genes_plot_gene_name[i],sep="")) + xlab("") + ylab("Normalized gene counts") + theme_bw() +
        theme(text = element_text(size=12),
                axis.text.x = element_text(angle=45, vjust=1,hjust=1))
        ggsave(filename=paste("differential_gene_expression/plots/boxplots_requested_genes/",requested_genes_plot_gene_name[i],"_",requested_genes_plot_Ensembl[i],".svg",sep=""), width=10, height=5, plot=plot)
        ggsave(filename=paste("differential_gene_expression/plots/boxplots_requested_genes/",requested_genes_plot_gene_name[i],"_",requested_genes_plot_Ensembl[i],".png",sep=""), width=10, height=5, plot=plot)
        ggsave(filename=paste("differential_gene_expression/plots/boxplots_requested_genes/",requested_genes_plot_gene_name[i],"_",requested_genes_plot_Ensembl[i],".pdf",sep=""), width=10, height=5, plot=plot)
    }
}
```

## Boxplots of gene normalized counts

Plots of the normalized counts were generated for some example genes. Count normalization was performed by
sequencing depth and adding a pseudocount of 1/2 to allow for log scale plotting.
The plots are available at [boxplots_example_genes](./differential_gene_expression/plots/boxplots_example_genes).

```{r setup3, echo=FALSE, message=FALSE, bootstrap.show.message=FALSE, include=FALSE}
gene=FALSE
df_gene <- try(read.table(params$path_genelist))
if (!inherits(df_gene, 'try-error')){
    names = rownames(df_gene)
    gene = TRUE
}
```

```{r genes_block, echo=FALSE, results='asis', eval=gene}
cat("Plots for the [genes of interest](./differential_gene_expression/metadata/gene_list.txt) can be found [here](./differential_gene_expression/plots/boxplots_requested_genes/).
\
")
```

<!-- In case KEGG analysis was also included; differentiating the cases with and without contrasts -->


<!-- PA start -->
```{r load_PA_libs, eval=params$pathway_analysis, echo=FALSE, message=FALSE, warning=FALSE, results = 'hide'}

# Load libs invisibly
invisible(lapply(c(
"gprofiler2",
"reshape2",
"pathview",
"AnnotationDbi",
"optparse",
"ggvenn"
), library, character.only=T))

# Create output directory
dir.create("pathway_analysis")

#The following installs the necessary species library
species_dir <- tempdir()
organism <- tolower(params$organism)
short_organism_name <- substr(organism,1,3)
if (!require("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}
BiocManager::install(params$species_library, lib=species_dir, version="3.14", force=T)
library(params$species_library, lib.loc=species_dir, character.only=T)
species_library_installed <- get(params$species_library)

# gprofiler pathway / term sources parameters
datasources <- c("KEGG", "REAC")

# Default to 1 for the nb of genes DE in a pathway
min_DEG_pathway <- as.integer(params$min_DEG_pathway)

# If background list is to be used, load custom background list
# if provided, else use notAllZero
if (isProvided(params$set_background)) {
    if (isProvided(params$custom_background)) {
        custom_background <- readLines(params$custom_background)
    } else {
        custom_background <- rownames(counts(cds))[notAllZero]
    }
}

# Contrast files
contrast_files <- list.files('differential_gene_expression/DE_genes_tables/')
path_contrasts <- 'differential_gene_expression/DE_genes_tables/'

# Reading metadata table
metadata <- metadata_PA
metadata$Secondary.Name <- gsub(" ; ", "_", metadata$Secondary.Name) # Remove blank spaces and ; from secondary name
metadata$Secondary.Name <- gsub(" ", "_", metadata$Secondary.Name) # Remove blank spaces if there from secondary name

#This saves whether a GMT file is present and should be moved to the pathway_analysis/metadata folder; initialize as FALSE
mv_status <- F

if (isProvided(params$custom_gmt)){

    # If custom GMT file was provided, filter it before uploading to use in gost queries (gprofiler will NOT filter itself, so otherwise the output will contain all kinds of datasources, not just the selected ones)
    out_gmt <- (Filter(function(line) any(startsWith(line, datasources)), readLines(params$custom_gmt)))
    out_path <- paste0(tools::file_path_sans_ext(basename(params$custom_gmt)), "_filtered.gmt")
    writeLines(out_gmt, out_path)
    gost_id <- upload_GMT_file(out_path)
    mv_status <- T
} else {

    # Otherwise, get the GMT file from gprofiler and save both the full file as well as the filtered one to metadata
    gost_id <- organism
    gmt_url <- paste0("https://biit.cs.ut.ee/gprofiler//static/gprofiler_full_", organism, ".ENSG.gmt")
    tryCatch(
        {
            wget_command <- paste0("wget ", gmt_url)
            sys_return <- system(wget_command)
            if (sys_return == 0 || "saved" %in% sys_return) {
                mv_status <- T
            } else {
                print("Failed to fetch the GMT file from gprofiler with this URL:")
                print(gmt_url)
                print("For reproducibility reasons, try to download the GMT file manually by visiting https://biit.cs.ut.ee/gprofiler/gost, then selecting the correct organism and finally, in datasources, clicking 'combined ENSG.gmt'.")
            }
        },
        error=function(gost_error) {
            print("Failed to fetch the GMT file from gprofiler with this URL:")
            print(gmt_url)
            print("Got error:")
            print(gost_error)
            print("For reproducibility reasons, please try to download the GMT file manually by visiting https://biit.cs.ut.ee/gprofiler/gost, then selecting the correct organism and finally, in datasources, clicking 'combined ENSG.gmt'. Then provide it to the pipeline with the parameter `--custom_gmt`")
        }
    )
}

# If GMT exist(s), create metadata folder and move GMT(s) there

if (mv_status) {
    dir.create("pathway_analysis/metadata")
    system("mv *.gmt pathway_analysis/metadata")
    if (isProvided(params$custom_gmt)) {
        system(paste("cp", params$custom_gmt, "pathway_analysis/metadata/"))
    }
}

# ------------------
# Set default params
# ------------------

# Set theme for graphs
theme_set(theme_classic())

# ----------------------
# Start pathway analysis
# ----------------------

# For each contrast do pathway analysis

for (file in contrast_files){

    #Reading DE genes list
    fname <- tools::file_path_sans_ext(basename(file))

    dir.create(paste("pathway_analysis", fname, sep="/"))
    dir.create(paste("pathway_analysis", fname, "KEGG_pathways", sep="/"))
    DE_genes <- read.csv(file = paste0(path_contrasts, file), sep="\t", header = T)
    DE_genes <- as.data.frame(DE_genes)

    # Skip pathway analysis for the contrast if not 2 or more DE genes were found
    if (nrow(DE_genes) < 2){
        print(paste0("Not enough DE genes to allow for a pathway analysis for contrast: ", fname))
        next
    }

    # Define list of Ensemble IDs (q) to run the pathway analysis
    q = as.character(DE_genes$Ensembl_ID)

    # gost query
    if (isProvided(params$set_background)) {
        gostres <- gost(query=q,
            organism=gost_id,
            significant=TRUE,
            correction_method="fdr",
            sources=datasources,
            evcodes=TRUE,
            user_threshold=params$adj_pval_threshold,
            custom_bg=custom_background,
            domain_scope="custom_annotated"
        )
        
        pathway_gostres <- gostres$result
        pathway_gostres <- as.data.frame(pathway_gostres[which(pathway_gostres$significant==TRUE),])
        pathway_gostres <- pathway_gostres[which(pathway_gostres$intersection_size>=min_DEG_pathway),]
        
        # Also run without bg for Venn diagrams
        gostres_nobg <- gost(query=q,
            organism=gost_id,
            significant=TRUE,
            correction_method="fdr",
            sources=datasources,
            evcodes=TRUE,
            user_threshold=params$adj_pval_threshold,
            domain_scope="annotated"
        )
        pathway_gostres_nobg <- gostres_nobg$result
        pathway_gostres_nobg <- as.data.frame(pathway_gostres_nobg[which(pathway_gostres_nobg$significant==TRUE),])
        pathway_gostres_nobg <- pathway_gostres_nobg[which(pathway_gostres_nobg$intersection_size>=min_DEG_pathway),]

    } else {
        gostres <- gost(query=q,
            organism=gost_id,
            significant=TRUE,
            correction_method="fdr",
            sources=datasources,
            evcodes=TRUE,
            user_threshold=params$adj_pval_threshold,
            domain_scope="annotated"
        )
    }


    # Make data frame of gost result
    pathway_gostres <- gostres$result

    # Select only significantly enriched pathways (according to adjusted p-value)
    pathway_gostres <- as.data.frame(pathway_gostres[which(pathway_gostres$significant==TRUE),])

    # Select only pathways with a min. number of DEG
    pathway_gostres <- pathway_gostres[which(pathway_gostres$intersection_size>=min_DEG_pathway),]
    gostres$result <- pathway_gostres

    # Plot pathways if there were any
    if (nrow(pathway_gostres) > 0){

        # annotate query size (number of DE genes in contrast)
        pathway_gostres$original_query_size <- rep(length(q), nrow(pathway_gostres))

        # Generate non-interactive pathway dotplots in the folder
        pg <- gostplot(gostres, capped=T, interactive=F)
        ggsave(pg, filename = paste0("pathway_analysis", "/", fname, "_gost_pathway_enrichment_plot.pdf"),
            device="pdf",
            height=10, width=15, units="cm", limitsize=F)
        ggsave(pg, filename = paste0("pathway_analysis", "/", fname, "_gost_pathway_enrichment_plot.png"),
            device="png",
            height=10, width=15, units="cm", dpi=300, limitsize=F)
        ggsave(pg, filename = paste0("pathway_analysis", "/", fname, "_gost_pathway_enrichment_plot.svg"),
            device="svg",
            height=10, width=15, units="cm", dpi=300, limitsize=F)

        # If background list was used for main PA analysis, plot Venn diagram of the results and those from the additional PA without background list
        if (isProvided(params$set_background)) {
            pathway_gostres_nobg <- gostres_nobg$result
            pathway_gostres_nobg <- as.data.frame(pathway_gostres_nobg[which(pathway_gostres_nobg$significant==TRUE),])
            pathway_gostres_nobg <- pathway_gostres_nobg[which(pathway_gostres_nobg$intersection_size>=min_DEG_pathway),]
            VennInput <- list(
                background=pathway_gostres$term_name,
                no_background=pathway_gostres_nobg$term_name
            )
            pv <- ggvenn::ggvenn(VennInput)
            ggsave(paste0("pathway_analysis", "/", fname, "_gost_pathway_venn_diagram.pdf"),pv, device="pdf", width=10, height=15)
            ggsave(paste0("pathway_analysis", "/", fname, "_gost_pathway_venn_diagram.png"),pv, device="png", width=10, height=15)
            ggsave(paste0("pathway_analysis", "/", fname, "_gost_pathway_venn_diagram.svg"),pv, device="svg", width=10, height=15)
        }
    }

    # Remove parents column to be able to save the table in tsv format
    pathway_gostres_table <- pathway_gostres
    pathway_gostres_table$parents <- NULL

    # Save pathway enrichment table in tsv format
    write.table(pathway_gostres_table,
                file = paste0("pathway_analysis", "/", fname, "/", fname, "_pathway_enrichment_results.tsv"),
                sep="\t", quote = F, col.names = T, row.names = F)

    print("------------------------------------")
    print(fname)
    print("Number of genes in query:")
    print(length(DE_genes$Ensembl_ID))
    print("Number of pathways found:")
    print(summary(as.factor(pathway_gostres_table$source)))
    print("------------------------------------")

    if (nrow(pathway_gostres) > 0){ #if there are enriched pathways

        # Splitting results according to pathway resources (KEGG / REACTOME / GO)
        res <- split(pathway_gostres, pathway_gostres$source)
        for (df in res){
            db_source <- df$source[1]
            df$short_name <- sapply(df$term_name, substr, start=1, stop=50)

            # Plotting results for df
            df_subset <- data.frame(Pathway_name = df$short_name, Pathway_code = df$term_id, DE_genes = df$intersection_size, Pathway_size = df$term_size, Fraction_DE = (df$intersection_size / df$term_size), Padj = df$p_value, DE_genes_names = df$intersection)
            write.table(df_subset,
                        file = paste0("pathway_analysis", "/", fname, "/", fname, "_", db_source, "_pathway_enrichment_results.tsv"),
                        sep="\t", quote = F, col.names = T, row.names = F)

            # Enriched pathways horizontal barplots of padj values
            p <- ggplot(df_subset, aes(x=reorder(Pathway_name, Fraction_DE), y=Fraction_DE)) +
                geom_bar(aes(fill=Padj), stat="identity", width = 0.7) +
                geom_text(aes(label=paste0(df_subset$DE_genes, "/", df_subset$Pathway_size)), vjust=0.4, hjust=-0.5, size=3) +
                coord_flip() +
                scale_y_continuous(limits = c(0.00, 1.00)) +
                scale_fill_continuous(high = "#132B43", low = "#56B1F7") +
                ggtitle("Enriched pathways") +
                xlab("") + ylab("Gene fraction (DE genes / Pathway size)")
            ggsave(p, filename = paste0("pathway_analysis", "/", fname, "/", fname, "_", db_source, "_pathway_enrichment_plot.pdf"), device = "pdf", height = 5+0.5*nrow(df_subset), units = "cm", limitsize=F)
            ggsave(p, filename = paste0("pathway_analysis", "/", fname, "/", fname,"_", db_source, "_pathway_enrichment_plot.png"), device = "png", height = 5+0.5*nrow(df_subset), units = "cm", dpi = 300, limitsize=F)
            ggsave(p, filename = paste0("pathway_analysis", "/", fname, "/", fname,"_", db_source, "_pathway_enrichment_plot.svg"), device = "svg", height = 5+0.5*nrow(df_subset), units = "cm", dpi = 300, limitsize=F)

            # Plotting heatmaps and KEGG pathways for all pathways
            print("Plotting heatmaps...")
            if (nrow(df) <= 100 & nrow(df) > 0) {
                conditions <- grepl("Condition", colnames(metadata))
                metadata_save <- as.data.frame(metadata[,conditions])
                metadata_name <- metadata[,c("QBiC.Code", "Secondary.Name")]
                row.names(metadata_save) <- apply(metadata_name,1,paste, collapse = "_")

                for (i in c(1:nrow(df))){
                    pathway <- df[i,]
                    gene_list <- unlist(strsplit(pathway$intersection, ","))
                    mat <- norm_counts[gene_list, ]
                    rownames(mat) <- mat$gene_name
                    mat$gene_name <- NULL
                    mat <- data.matrix(mat)

                    # Skip the heatmaps for CI tests because especially png() works only very unreliably for the heatmaps for some reason
                    if (!isProvided(params$citest) & nrow(mat)>1){
                        dir.create(paste("pathway_analysis", fname, "pathway_heatmaps", sep="/"))
                        
                        # Because the image devices sometimes don't work here, surround them with a tryCatch so that the code continues even if a certain heatmap is not saved                         
                        tryCatch(
                            {
                                png(filename = paste0("pathway_analysis", "/",fname, "/", "pathway_heatmaps", "/", "Heatmap_normalized_counts_", pathway$source, "_", pathway$term_id, "_",fname, ".png"), width = ifelse(nrow(mat)<=20, 200, 125)+ncol(mat)*40, height = 50+nrow(mat)*50)
                                pheatmap(mat = mat, annotation_col = metadata_save, main = paste("Heatmap of normalized expression values for genes in pathway ", pathway$short_name, "(",pathway$source,")",sep=" "), scale = "row", cluster_cols = F, cluster_rows = T)
                                dev.off()
                            },
                            error=function(e) {
                                print(paste0("Could not save Heatmap_normalized_counts_", pathway$source, "_", pathway$term_id, "_",fname, ".png because of the following error:\n", e))
                            }
                        )
                        tryCatch(
                            {
                                pdf(paste0("pathway_analysis", "/", fname, "/", "pathway_heatmaps", "/", "Heatmap_normalized_counts_", pathway$source, "_", pathway$term_id, "_", fname, ".pdf"), width = ifelse(nrow(mat)<=20, 50, 10)+ncol(mat)*0.1, height = 5+nrow(mat)*0.005)
                                pheatmap(mat = mat, annotation_col = metadata_save, main = paste("Heatmap of normalized expression values for genes in pathway ", pathway$short_name, "(",pathway$source,")",sep=" "), scale = "row", cluster_cols = F, cluster_rows = T)
                                dev.off()
                            },
                            error=function(e) {
                                print(paste0("Could not save Heatmap_normalized_counts_", pathway$source, "_", pathway$term_id, "_", fname, ".pdf because of the following error:\n", e))
                            }
                        )
                        tryCatch(
                            {
                                svg(paste0("pathway_analysis", "/", fname, "/", "pathway_heatmaps", "/", "Heatmap_normalized_counts_", pathway$source, "_", pathway$term_id, "_", fname, ".svg"), width = ifelse(nrow(mat)<=20, 50, 10)+ncol(mat)*0.1, height = 5+nrow(mat)*0.005)
                                pheatmap(mat = mat, annotation_col = metadata_save, main = paste("Heatmap of normalized expression values for genes in pathway ", pathway$short_name, "(",pathway$source,")",sep=" "), scale = "row", cluster_cols = F, cluster_rows = T)
                                dev.off()
                            },
                            error=function(e) {
                                print(paste0("Could not save Heatmap_normalized_counts_", pathway$source, "_", pathway$term_id, "_", fname, ".svg because of the following error:\n", e))
                            }
                        )
                    }

                    # Plotting pathway view only for kegg pathways
                    if (pathway$source == "KEGG"){
                        pathway_kegg <- sapply(pathway$term_id, function(x) paste0(short_organism_name, unlist(strsplit(as.character(x), ":"))[2]))

                        # Try plotting pathways, ignore pathways graphs containing errors as pathview crashes if plotting them.
                        tryCatch({
                            print_string <- paste0("Plotting pathway: ", pathway_kegg)
                            gene.data = DE_genes
                            gene.data.subset = gene.data[gene.data$Ensembl_ID %in% gene_list, c("Ensembl_ID","log2FoldChange")]

                            entrez_ids = AnnotationDbi::mapIds(species_library_installed, keys=as.character(gene.data.subset$Ensembl_ID), column = "ENTREZID", keytype=params$keytype, multiVals="first")

                            gene.data.subset <- gene.data.subset[!(is.na(entrez_ids)),]

                            if (length(entrez_ids)!=length(unique(entrez_ids))) {
                                print_string <- paste0("Skipping pathway: ", pathway_kegg,". This pathway has multiple IDs with same name.")
                            } else {
                                row.names(gene.data.subset) <- entrez_ids[!is.na(entrez_ids)]
                                gene.data.subset$Ensembl_ID <- NULL
                                pathview(gene.data  = gene.data.subset,
                                        pathway.id = pathway_kegg,
                                        species    = short_organism_name,
                                        out.suffix=paste(fname,sep="_"))
                                mv_command <- paste0("mv *.png *.xml ","./","pathway_analysis", "/",fname, "/", "KEGG_pathways", "/")
                                rm_command <- paste0("rm ","./","pathway_analysis", "/",fname, "/", "KEGG_pathways", "/", "*.xml")
                                system(mv_command)
                            }
                        }, error = function(e) {
                            print_string <- paste0("Skipping pathway: ",pathway_kegg,". This pathway file has errors in KEGG database.")
                        }, finally = {
                            print(print_string)
                        })
                    }
                }
            }
        }
    }
}

# Plotting heatmap for provided gene list
if (isProvided(params$path_genelist)){

    genelist_path = params$path_genelist
    genelist_heatmaps_dir <- "heatmap_gene_list"
    dir.create(paste("pathway_analysis", genelist_heatmaps_dir, sep="/"))

    print("Plotting heatmaps...")
    conditions <- grepl("Condition", colnames(metadata))
    condition <- metadata[,conditions]
    metadata_save <- as.data.frame(condition)
    metadata_name <- metadata[,c("QBiC.Code", "Secondary.Name")]
    row.names(metadata_save) <- apply(metadata_name,1,paste, collapse = "_")

    gene_list_tab <- read.table(file=genelist_path, sep = "\t", header = F, quote="")
    gene_list_unique_tab <- data.frame(gene_list=unique(gene_list_tab$V1))

    norm_counts$gene_name <- toupper(norm_counts$gene_name)
    IDs <- norm_counts[,c("Ensembl_ID","gene_name")]

    genestoEnsmbl <- merge(x=gene_list_unique_tab, y=IDs, by.x="gene_list", by.y="gene_name", all.x=T)
    gene_list <- genestoEnsmbl$Ensembl_ID

    # Omit genes not present in the count table (NAs)
    gene_list <- na.omit(gene_list)

    rownames(norm_counts) <- norm_counts$Ensembl_ID
    mat <- norm_counts[gene_list, ]
    rownames(mat) <- mat$gene_name
    mat$gene_name <- NULL
    mat$Ensembl_ID <- NULL
    mat <- data.matrix(mat)

    if (nrow(mat)>1){
        png(filename = paste0("pathway_analysis", "/", genelist_heatmaps_dir, "/", "Heatmap_normalized_counts_gene_list.png"), width = 100+ncol(mat)*50, height = 50+nrow(mat)*100)
        pheatmap(mat = mat, annotation_col = metadata_save, main = "Genelist-specific heatmap of normalized expression values for genes", scale = "row", cluster_cols = F, cluster_rows = T)
        dev.off()
        pdf(paste0("pathway_analysis", "/", genelist_heatmaps_dir, "/", "Heatmap_normalized_counts_gene_list.pdf"), width = 10+ncol(mat)*0.05, height = 5+nrow(mat)*0.005)
        pheatmap(mat = mat, annotation_col = metadata_save, main = "Genelist-specific heatmap of normalized expression values for genes", scale = "row", cluster_cols = F, cluster_rows = T)
        dev.off()
        svg(paste0("pathway_analysis", "/", genelist_heatmaps_dir, "/", "Heatmap_normalized_counts_gene_list.svg"), width = 10+ncol(mat)*0.1, height = 5+nrow(mat)*0.005)
        pheatmap(mat = mat, annotation_col = metadata_save, main = "Genelist-specific heatmap of normalized expression values for genes", scale = "row", cluster_cols = F, cluster_rows = T)
        dev.off()
    }
}
```

```{r pathway_analysis, echo=FALSE, results='asis', eval=params$pathway_analysis}

if (mv_status) {
    if (isProvided(params$custom_gmt)) {
        gost_text <- "A custom GMT file was provided for the gost query; it is saved [here](./pathway_analysis/metadata). In case this GMT file contained entries from datasources other than the selected ones, it was filtered and the resulting filtered GMT was used for querying. The filtered version is also saved to the metadata folder."
    } else {
        gost_text <- "A GMT file corresponding to the current gprofiler database version was downloaded to allow for reproducing the gost query; it is saved [here](./pathway_analysis/metadata). Note that the downloaded GMT contains entries from various datasources, not just the selected ones. Also, some datasources might be missing from the files due to licensing reasons."
    }
} else {
    gost_text <- paste0("Failed to fetch the GMT file of the current gprofiler database with this URL: ", gmt_url, ". For reproducibility reasons, try to download the GMT file manually by visiting https://biit.cs.ut.ee/gprofiler/gost, then selecting the correct organism and finally, in datasources, clicking 'combined ENSG.gmt'.")
}

# The following details block creates a collapsible explaining the output folders/files
cat(paste0("***

# Pathway analysis
The pathway analysis was performed with the `gProfiler2` tool.

After unzipping the results ZIP file, the pathway analysis results are stored in this folder: [pathway_analysis/](./pathway_analysis), and explained in this section.
Inside the pathway analysis results folder, a subfolder for each contrast used for the differential gene expression analysis is found. Inside each contrast folder, there is the following output:
<br><br><details>
<summary>Expand/collapse</summary>
- `*_gost_pathway_venn_diagram.pdf/png`
  - Venn diagrams showing the numbers of enriched pathways when using a background gene list vs when not using a bg list.
- `*_KEGG_pathway_enrichment_plot.pdf/png`
    - Barplots showing the proportion of differentially expressed genes in the pathway.
- `KEGG_pathways/`
    - Contains the KEGG pathways graphs with the log fold change of the differentially expressed genes.
- `pathway_heatmaps`
    - Contains heatmaps of the normalized gene counts for each of the differentially expressed pathways.
</details><br>",
gost_text,

"\n
## Enriched pathways
The plot below summarizes the pathways that were found significantly enriched in DE genes for each contrast (padj value <= ", pval_text, ").
Only contrasts for which an enriched pathway was found are shown. Both KEGG pathways and REACTOME (REAC) pathways are considered.
Hover over the dots to reveal the pathway names. The table below provides more detail on all enriched pathways."))
```

```{r gost, eval=params$pathway_analysis, out.height = "100%", out.width = "100%", warning=FALSE, message=FALSE}
contrast_files <- list.files(path=paste0("differential_gene_expression/DE_genes_tables/"))
q_list <- list()
q_names <- c()

#Use non-allgenes files for PA to only show DE genes
for (file in contrast_files){

    #Reading DE genes list
    fname <- tools::file_path_sans_ext(basename(file))
    DE_genes <- read.csv(file = paste0("differential_gene_expression/DE_genes_tables/", file), sep="\t", header = T)

    if(nrow(DE_genes) <= 1){
        next
    }
    q = as.character(DE_genes$Ensembl_ID)
    q_list <- append(q_list, list(q))
    q_names <- append(q_names, fname)

}
names(q_list) <- q_names
if (length(q_list) > 0) {

    #gost query
    
    if (isProvided(params$set_background)) {
        gostres <- gost(query=q_list,
                    organism=gost_id,
                    significant=T,
                    correction_method="fdr",
                    sources=datasources,
                    user_threshold=params$adj_pval_threshold,
                    custom_bg=custom_background,
                    domain_scope="custom_annotated"
        )
    } else {
        gostres <- gost(query=q_list,
                    organism=gost_id,
                    significant=T,
                    correction_method="fdr",
                    sources=datasources,
                    user_threshold=params$adj_pval_threshold,
                    domain_scope="annotated"
        )
    }

    path_enrich <- as.data.frame(gostres$result)
    if (nrow(path_enrich) > 0){
        pg2 <- gostplot(gostres, capped=T, interactive=T)
        pg2[['x']][['layout']][['annotations']][[1]][['x']] <- -params$adj_pval_threshold

        #limit gostplot y maximum
        for (counter in c(1:length(contrast_files))) {
            pg2[['x']][['layout']][[paste0('yaxis', ifelse(counter>1, counter, ""))]][['range']] <- c(0,ceiling(2*-log10(max(gostres$p_value))))
        }

        #add export button to plot
        config(pg2, modeBarButtonsToAdd = list(svg_exp)) %>% layout(width=500, height = 400*length(contrast_files))
    } else {
            cat("No enriched pathways were found.")
            path_enrich=data.frame(list())
    }
} else {
    cat("No DE genes were found, pathway analysis not possible.")
    path_enrich=data.frame(list())
}
```

```{r enriched_table, eval=params$pathway_analysis, echo=FALSE}
if (nrow(path_enrich) > 0) {
    df_subset <- data.frame(Contrast = path_enrich$query, Pathway_name = path_enrich$term_name, Pathway_code = path_enrich$term_id,
    DE_genes = path_enrich$intersection_size, Pathway_size = path_enrich$term_size,
    Fraction_DE = formatC(path_enrich$intersection_size / path_enrich$term_size, digits=3),
    Padj = formatC(path_enrich$p_value, digits=3))
    colnames <- c("Contrast", "Pathway name", "Pathway code", "DE genes in pathway (N)", "Total genes in pathway (N)",
    "Fraction of DE genes in pathway", "Padj value (pathway enrichment)")
    DT::datatable(df_subset, options = list(scrollX  = "100%", scrollY = "400px", pageLength = -1, dom = 'ft'))
}
```

```{r conditional_KEGG_contrasts, echo=FALSE, results='asis', eval=params$pathway_analysis}
cat(paste0("## KEGG pathway maps
For KEGG pathways, a KEGG pathway map was also generated that can be found in the subfolder named `KEGG_pathways`, for each contrast folder.
\
"))
```

```{r conditional_pathway_maps, echo=FALSE, results='asis', eval=params$pathway_analysis}
cat(paste0("## Pathway heatmaps
For all considered contrasts, a heatmap of all DE genes that were found in each of the pathways is produced.
You can find these heatmaps inside the [pathway_analysis](./pathway_analysis) folder, inside the subfolder corresponding to each of the contrasts,
and the subfolder: `pathway_heatmaps`.
\
"))
```
<!-- PA end -->

# Summary and outlook

```{r quote, echo=FALSE, results='asis'}
# Only add hyperlink to quote file if it was provided in the params
quote_string <- ifelse(
    isProvided(params$path_quote),
    paste0("The results for all work packages, as described in the [quote/offer](", params$path_quote, "), can be found in this report."),
    paste0("The results for all work packages (no quote/offer given to describe them) can be found in this report.")
)
cat(quote_string)

# Initiate var in case no software_versions were provided
software_versions_csv <- F
```

Further support for this project will be restricted to the results presented in this report.
For further analysis (e.g. the re-analysis of the dataset) we will generate a new quote containing cost estimates.

```{r software_versions, bootstrap.show.message=FALSE, echo=FALSE, message=FALSE, eval=isProvided(params$path_software_versions)}
# Import the .csv or .yml file output by the rna-seq Nextflow pipeline
software_versions_csv <- endsWith(params$path_software_versions, ".csv") || endsWith(params$path_software_versions, ".tsv")
if (software_versions_csv) {
    version_csv <- read.csv(file = params$path_software_versions, sep="\t", header = FALSE)
    version <- setNames(as.list(version_csv$V2), version_csv$V1)
} else {
    version <- read_yaml(params$path_software_versions)
}

if (software_versions_csv) {
    if (params$input_type == "featurecounts") {
        quant_tool <- "featureCounts"
        quant_version <- as.character(version["featureCounts"])
        quant_cite <- "[@liao2014featurecounts]"
    }
} else if (!(software_versions_csv)) {
    if (params$input_type == "rsem") {
        quant_tool <- "RSEM"
        quant_version <- as.character(version["RSEM_CALCULATEEXPRESSION"][[1]]["rsem"])
        quant_cite <- "[@li2011rsem]"
    } else if (params$input_type == "salmon") {
        quant_tool <- "Salmon"
        quant_version <- as.character(version["SALMON_QUANT"][[1]]["salmon"])
        quant_cite <- "[@patro2017salmon]"
    }
}
```

<!-- TODO all software_versions right (+gprofiler2, reference genome) and nicer description of computational methods -->

# Computational methods

```{r software_versions_RNASeq, echo=FALSE, results='asis', eval=isProvided(params$path_software_versions)}

# In the following part, I use newlines (in code) where possible whenever the paste0 function switches from a string to a variable call to better distinguish between the two so it is obvious in which lines quotes are needed and in which not --> Cannot always use newlines as this sometimes translates into the report.html

cat(paste0(
"## RNAseq data analysis
    
The Nextflow-based nf-core pipeline `rnaseq ", as.character(ifelse(software_versions_csv, version["nf-core/rnaseq"], version["Workflow"][[1]]["nf-core/rnaseq"])),
"` [^1] was used for the RNAseq Bioinfomatics analysis. `FASTQC ",
as.character(ifelse(software_versions_csv, version["FastQC"], version["FASTQC"][[1]]["fastqc"])),
"` [^3] [@andrews2010fastqc] was used to determine quality of the FASTQ files.
Subsequently, adapter trimming was conducted with `Trim Galore ",
as.character(ifelse(software_versions_csv, version["Trim Galore!"], version["TRIMGALORE"][[1]]["trimgalore"])),
"` [^4] [@krueger2012trim]. `STAR v",
as.character(ifelse(software_versions_csv, substring((version["STAR"]), 7, ), version["MAKE_TRANSCRIPTS_FASTA"][[1]]["star"])),
"` [@Dobin2013] aligner was used to map the reads that passed the quality control to the reference genome.
The RNA-seq data quality control was performed with `RSeQC ",
as.character(ifelse(software_versions_csv, version["RSeQC"], version["RSEQC_BAMSTAT"][[1]]["rseqc"])),
"` [@wang2012rseqc] and read quantification of the features (e.g. genes) with `",
quant_tool,
" ",
quant_version,
"` ",
quant_cite,
"."
))

```{r MQC_cite, echo=FALSE, results='asis', eval=software_versions_csv&isProvided(params$path_software_versions)}
cat(paste0("\nAn aggregation of the quality control for the RNAseq analysis was performed with `MultiQC ", as.character(version["MultiQC"]), "` [^2] [@ewels2016multiqc]."))
```

```{r software_versions_DE, echo=FALSE, results='asis', eval=isProvided(params$path_software_versions)}

cat(paste0(
"## Differential gene expression analysis

The differential expression analysis was performed by the use of the `rnadeseq ",
as.character(params$revision),
"` pipeline [^5], which was written using the nf-core template [@ewels2020nf]. For differential expression analysis, the read quantification data resulting from `",
quant_tool, "` were processed with the R package `DESeq2 v",
packageVersion("DESeq2"),
"` [@love2014differential]. The thresholds for differentially expressed genes were set to ", 
pval_text, " for the p-value and ",
logFC_text, " for the log2 Fold Change."
))

```{r conditional_pathway, echo=FALSE, results='asis', eval=isProvided(params$pathway_analysis)&isProvided(params$path_software_versions)}
version_gprofiler2 = packageVersion("gprofiler2")
version_annotation = packageVersion("AnnotationDbi")
name_species       = params$species_library
version_species    = packageVersion(name_species)

if (isProvided(params$custom_gmt)){
    database_string <- paste0("Also, a gprofiler query with this custom GMT file was done: `", basename(params$custom_gmt), "`. Entries of the following datasources were considered: ")
    dbs <- paste(datasources, collapse="`, `")
    database_string <- paste0(database_string, "`", dbs, "`.")
} else {
    database_string = "Also, the following databases were queried: "
    database_version_info <- get_version_info(params$organism)
    database_string <- paste0(database_string, "`gprofiler: ", database_version_info$gprofiler_version, "`")
    for (db in datasources) {
        database_string <- paste0(database_string, ", `", db, ": ", database_version_info$sources[[db]]$version, "`")
    }
}

cat(paste0(
"\n## Pathway enrichment analysis

For pathway analysis, the R packages `gprofiler2 v", version_gprofiler2,
" `, `AnnotationDbi v", version_annotation,
"` and `", name_species, " v", version_annotation,
"` were used. ", database_string, ".\n",
"Pathways were classified as enriched for those genes with an adjusted p-value <= ", pval_text, "."
))
```

Graphs were produced in RStudio with ``r R.version.string`` mainly using the R package `ggplot2 v`r packageVersion("ggplot2")`` . Final reports were produced using the R package `rmarkdown v`r packageVersion("rmarkdown") ``, with the `knitr v`r packageVersion("knitr")`` and `DT v`r packageVersion("DT")`` R packages.

## Package version overview

The following lists all packages used for analysis, together with their versions.

```{r versions}
sessioninfo::session_info()%>%
  details::details(summary = 'Session info/used packages')
```

---

---

# Bibliography

[^1]: https://github.com/nf-core/rnaseq
[^2]: http://multiqc.info/
[^3]: https://www.bioinformatics.babraham.ac.uk/projects/fastqc/
[^4]: https://www.bioinformatics.babraham.ac.uk/projects/trim_galore/
[^5]: https://github.com/qbic-pipelines/rnadeseq

